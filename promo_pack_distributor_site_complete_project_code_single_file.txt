./tailwind.config.ts
---
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
export default config

---
./postcss.config.mjs
---
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;


---
./next.config.mjs
---
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;


---
./tsconfig.json
---
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


---
./package.json
---
{
  "name": "pastel-inference-client-web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ant-design/icons": "^5.5.1",
    "antd": "^5.21.2",
    "axios": "^1.7.7",
    "crypto-js": "^4.2.0",
    "next": "14.2.14",
    "pako": "^2.1.0",
    "react": "^18",
    "react-dom": "^18",
    "zod": "^3.23.8",
    "zustand": "^5.0.0-rc.2"
  },
  "devDependencies": {
    "@types/crypto-js": "^4.2.2",
    "@types/node": "^20",
    "@types/pako": "^2.0.3",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "eslint": "^8",
    "eslint-config-next": "14.2.14",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.13",
    "typescript": "^5"
  }
}


---
./promo_pack_distributor_site_complete_project_code_single_file.txt
---
./tailwind.config.ts
---
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
export default config

---
./postcss.config.mjs
---
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;


---
./next.config.mjs
---
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;


---
./tsconfig.json
---
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


---
./package.json
---
{
  "name": "pastel-inference-client-web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ant-design/icons": "^5.5.1",
    "antd": "^5.21.2",
    "axios": "^1.7.7",
    "crypto-js": "^4.2.0",
    "next": "14.2.14",
    "pako": "^2.1.0",
    "react": "^18",
    "react-dom": "^18",
    "zod": "^3.23.8",
    "zustand": "^5.0.0-rc.2"
  },
  "devDependencies": {
    "@types/crypto-js": "^4.2.2",
    "@types/node": "^20",
    "@types/pako": "^2.0.3",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "eslint": "^8",
    "eslint-config-next": "14.2.14",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.13",
    "typescript": "^5"
  }
}


---


---
./src/app/page.tsx
---
'use client'

import { useEffect } from 'react'
import { Typography } from 'antd'
import CreditPackTable from '@/components/CreditPackTable'
import InferenceForm from '@/components/InferenceForm'
import useStore from '@/store/useStore'

const { Title } = Typography

export default function Home() {
  const { pastelId, setPastelId, creditPacks, setCreditPacks } = useStore()

  useEffect(() => {
    // Fetch initial data
    // This is where you'd call your API to get PastelID, credit packs, etc.
  }, [])

  return (
    <main>
      <Title>Welcome to Pastel Inference Client</Title>
      <CreditPackTable creditPacks={creditPacks} />
      <InferenceForm pastelId={pastelId} />
    </main>
  )
}

---
./src/app/globals.css
---
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}


---
./src/app/layout.tsx
---
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import Layout from '@/components/Layout'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Pastel Inference Client',
  description: 'Modern Next.js 14 Pastel Inference Client',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Layout>{children}</Layout>
      </body>
    </html>
  )
}

---
./src/app/lib/globals.ts
---
// src/app/lib/globals.ts

'use client'

import { PastelGlobals } from '@/app/types';

const pastelGlobals: PastelGlobals = {
  MY_LOCAL_PASTELID: null,
  MY_PASTELID_PASSPHRASE: null,
  MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE: 1000,

  setPastelIdAndPassphrase(pastelId: string, passphrase: string): void {
    this.MY_LOCAL_PASTELID = pastelId;
    this.MY_PASTELID_PASSPHRASE = passphrase;
  },

  getPastelIdAndPassphrase(): { pastelID: string | null; passphrase: string | null } {
    return { pastelID: this.MY_LOCAL_PASTELID, passphrase: this.MY_PASTELID_PASSPHRASE };
  },

  getPastelId(): string | null {
    return this.MY_LOCAL_PASTELID;
  },

  getPassphrase(): string | null {
    return this.MY_PASTELID_PASSPHRASE;
  },

}

export default pastelGlobals;

---
./src/app/lib/storage.ts
---
// src/app/lib/storage.ts

'use client'

import BrowserRPCReplacement from "./BrowserRPCReplacement";
import { BrowserDatabase } from './BrowserDatabase';
import { PastelID } from '@/app/types';
import browserLogger from '@/app/lib/logger';


class BrowserStorage {
  private browserDB: BrowserDatabase;
  private rpcReplacement: BrowserRPCReplacement;
  private storageInitialized: boolean;

  constructor() {
    this.browserDB = new BrowserDatabase();
    this.rpcReplacement = new BrowserRPCReplacement();
    this.storageInitialized = false;
  }

  async initializeStorage(): Promise<void> {
    if (!this.storageInitialized) {
      try {
        await this.browserDB.initializeDatabase();
        browserLogger.info("Storage initialized successfully");
        this.storageInitialized = true;
      } catch (error) {
        browserLogger.error(
          `Error initializing storage: ${(error as Error).message.slice(0, 100)}`
        );
        throw error;
      }
    }
  }

  async getCurrentPastelIdAndPassphrase(): Promise<PastelID> {
    try {
      await this.initializeStorage();
      const pastelID = localStorage.getItem("MY_LOCAL_PASTELID");
      const passphrase = localStorage.getItem("MY_PASTELID_PASSPHRASE");

      if (!pastelID || !passphrase) {
        browserLogger.warn("PastelID or passphrase not found in storage");
        return { pastelID: null, passphrase: null };
      }

      browserLogger.info(`Retrieved PastelID from storage: ${pastelID}`);
      return { pastelID, passphrase };
    } catch (error) {
      browserLogger.error(
        `Error retrieving PastelID and passphrase: ${(error as Error).message.slice(0, 100)}`
      );
      return { pastelID: null, passphrase: null };
    }
  }

  async setPastelIdAndPassphrase(pastelID: string, passphrase: string): Promise<void> {
    if (!pastelID || !passphrase) {
      browserLogger.error("Attempted to set empty PastelID or passphrase");
      throw new Error("PastelID and passphrase must not be empty");
    }

    try {
      await this.initializeStorage();
      localStorage.setItem("MY_LOCAL_PASTELID", pastelID);
      localStorage.setItem("MY_PASTELID_PASSPHRASE", passphrase);
      browserLogger.info(`Set PastelID: ${pastelID}`);
    } catch (error) {
      browserLogger.error(
        `Error setting PastelID and passphrase: ${(error as Error).message.slice(0, 100)}`
      );
      throw error;
    }
  }

  async storeData<T>(storeName: string, data: T): Promise<IDBValidKey> {
    await this.initializeStorage();
    return this.browserDB.addData(storeName, data);
  }

  async retrieveData<T>(storeName: string, id: IDBValidKey): Promise<T | undefined> {
    await this.initializeStorage();
    return this.browserDB.getData<T>(storeName, id);
  }

  async updateData<T>(storeName: string, id: IDBValidKey, data: T): Promise<IDBValidKey> {
    await this.initializeStorage();
    return this.browserDB.updateData(storeName, id, data);
  }

  async deleteData(storeName: string, id: IDBValidKey): Promise<void> {
    await this.initializeStorage();
    return this.browserDB.deleteData(storeName, id);
  }

  async performRPCOperation<T>(method: keyof BrowserRPCReplacement, ...args: unknown[]): Promise<T> {
    return (this.rpcReplacement[method] as (...args: unknown[]) => Promise<T>)(...args);
  }

  async getNetworkFromLocalStorage(): Promise<string> {
    return localStorage.getItem('PASTEL_NETWORK') || 'Mainnet';
  }

  async setNetworkInLocalStorage(network: string): Promise<void> {
    localStorage.setItem('PASTEL_NETWORK', network);
  }
}

// Create and export a singleton instance
const browserStorage = new BrowserStorage();

export default browserStorage;

// Utility functions
export async function getCurrentPastelIdAndPassphrase(): Promise<PastelID> {
  return browserStorage.getCurrentPastelIdAndPassphrase();
}

export async function setPastelIdAndPassphrase(pastelID: string, passphrase: string): Promise<void> {
  return browserStorage.setPastelIdAndPassphrase(pastelID, passphrase);
}

export async function getNetworkFromLocalStorage(): Promise<string> {
  return browserStorage.getNetworkFromLocalStorage();
}

export async function setNetworkInLocalStorage(network: string): Promise<void> {
  return browserStorage.setNetworkInLocalStorage(network);
}

export async function storeSecureContainer(
    pastelID: string,
    secureContainer: string,
    network: string
  ): Promise<void> {
    const key = `secureContainer_${pastelID}_${network}`;
    localStorage.setItem(key, secureContainer);
  }

---
./src/app/lib/utils.ts
---
// src/app/lib/utils.ts

'use client'

import CryptoJS from "crypto-js";
import pako from "pako";
import browserLogger from "@/app/lib/logger";
import BrowserRPCReplacement from "@/app/lib/BrowserRPCReplacement";
import * as storage from "@/app/lib/storage";
import { cacheInstance } from "@/app/lib/cache";
import {
  SupernodeInfo,
  ValidationError,
  AuditResult,
  InferenceResultDict,
  InferenceAPIUsageResponse,
  InferenceAPIOutputResult,
  ValidationResult,
  CreditPackPurchaseRequestResponse,
  SupernodeWithDistance,
} from "@/app/types";

const rpc = new BrowserRPCReplacement();

const MAX_CACHE_AGE_MS = 1 * 60 * 1000; // 1 minute in milliseconds

// Constants
const TARGET_VALUE_PER_CREDIT_IN_USD = parseFloat(
  localStorage.getItem("TARGET_VALUE_PER_CREDIT_IN_USD") || "0.01"
);
const TARGET_PROFIT_MARGIN = parseFloat(
  localStorage.getItem("TARGET_PROFIT_MARGIN") || "0.1"
);
const MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING =
  parseFloat(
    localStorage.getItem(
      "MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING"
    ) || "0.001"
  );
const MAXIMUM_LOCAL_PASTEL_BLOCK_HEIGHT_DIFFERENCE_IN_BLOCKS = parseInt(
  localStorage.getItem(
    "MAXIMUM_LOCAL_PASTEL_BLOCK_HEIGHT_DIFFERENCE_IN_BLOCKS"
  ) || "10"
);

// Helper functions
export function safeStringify(obj: unknown): string {
  return JSON.stringify(obj, (key, value) =>
    typeof value === "bigint" ? value.toString() : value
  );
}

export function generateUUID(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0,
      v = c == "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

export async function retryPromise<T>(
  promiseFunc: () => Promise<T>,
  retryLimit: number
): Promise<T> {
  let lastError: Error | null = null;
  for (let i = 0; i < retryLimit; i++) {
    try {
      return await promiseFunc();
    } catch (error) {
      lastError = error as Error;
    }
  }
  throw lastError;
}

// Cache functions

export async function clearOldCache(): Promise<void> {
  const keys = cacheInstance.findAll();
  const currentTime = Date.now();
  for (const key of keys) {
    const item = cacheInstance.findByPk(key);
    if (item && item.timestamp) {
      if (currentTime - item.timestamp > MAX_CACHE_AGE_MS) {
        cacheInstance.destroy({ where: { key } });
      }
    } else {
      cacheInstance.destroy({ where: { key } });
    }
  }
}

export async function storeInCache<T>(key: string, data: T): Promise<void> {
  cacheInstance.set(key, data);
}

export async function getFromCache<T>(key: string): Promise<T | null> {
  return cacheInstance.get(key) as T | null;
}

// Market price functions
export async function fetchCurrentPSLMarketPrice(): Promise<number> {
  async function checkPrices(): Promise<{
    priceCMC: number | null;
    priceCG: number | null;
  }> {
    try {
      const [responseCMC, responseCG] = await Promise.all([
        fetch("https://coinmarketcap.com/currencies/pastel/"),
        fetch(
          "https://api.coingecko.com/api/v3/simple/price?ids=pastel&vs_currencies=usd"
        ),
      ]);
      const textCMC = await responseCMC.text();
      const priceCMCMatch = textCMC.match(/price today is \$([0-9.]+) USD/);
      const priceCMC = priceCMCMatch ? parseFloat(priceCMCMatch[1]) : null;
      const jsonCG = await responseCG.json();
      const priceCG = jsonCG.pastel?.usd ?? null;
      return { priceCMC, priceCG };
    } catch (error) {
      browserLogger.error(
        `Error fetching PSL market prices: ${(error as Error).message}`
      );
      return { priceCMC: null, priceCG: null };
    }
  }

  let { priceCMC, priceCG } = await checkPrices();
  if (priceCMC === null && priceCG === null) {
    await new Promise((resolve) => setTimeout(resolve, 2000));
    ({ priceCMC, priceCG } = await checkPrices());
  }

  const prices = [priceCMC, priceCG].filter(
    (price): price is number => price !== null
  );
  if (prices.length === 0) {
    throw new Error("Could not retrieve PSL price from any source.");
  }

  const averagePrice =
    prices.reduce((sum, price) => sum + price, 0) / prices.length;
  if (averagePrice < 0.0000001 || averagePrice > 0.02) {
    throw new Error(`Invalid PSL price: ${averagePrice}`);
  }

  browserLogger.info(
    `The current Average PSL price is: $${averagePrice.toFixed(8)} based on ${
      prices.length
    } sources`
  );
  return averagePrice;
}

export async function estimatedMarketPriceOfInferenceCreditsInPSLTerms(): Promise<number> {
  try {
    const pslPriceUSD = await fetchCurrentPSLMarketPrice();
    const costPerCreditUSD =
      TARGET_VALUE_PER_CREDIT_IN_USD / (1 - TARGET_PROFIT_MARGIN);
    const costPerCreditPSL = costPerCreditUSD / pslPriceUSD;
    browserLogger.info(
      `Estimated market price of 1.0 inference credit: ${costPerCreditPSL.toFixed(
        4
      )} PSL`
    );
    return costPerCreditPSL;
  } catch (error) {
    browserLogger.error(
      `Error calculating estimated market price of inference credits: ${safeStringify(
        (error as Error).message
      )}`
    );
    throw error;
  }
}

// Utility functions
export function parseAndFormat(value: unknown): string {
  try {
    if (typeof value === "string") {
      if (value.includes("\n")) {
        return value;
      }
      const parsedValue = JSON.parse(value);
      return JSON.stringify(parsedValue, null, 4);
    }
    return JSON.stringify(value, null, 4);
  } catch {
    return String(value);
  }
}

export function prettyJSON(data: unknown): string {
  if (data instanceof Map) {
    data = Object.fromEntries(data);
  }
  if (Array.isArray(data) || (typeof data === "object" && data !== null)) {
    const formattedData: { [key: string]: unknown } = {};
    for (const [key, value] of Object.entries(data)) {
      if (typeof value === "string" && key.endsWith("_json")) {
        formattedData[key] = parseAndFormat(value);
      } else if (typeof value === "object" && value !== null) {
        formattedData[key] = prettyJSON(value);
      } else {
        formattedData[key] = value;
      }
    }
    return JSON.stringify(formattedData, null, 4);
  } else if (typeof data === "string") {
    return parseAndFormat(data);
  }
  return String(data);
}

export function abbreviateJSON(jsonString: string, maxLength: number): string {
  if (jsonString.length <= maxLength) return jsonString;
  const abbreviated = jsonString.slice(0, maxLength) + "...";
  const openBraces =
    (jsonString.match(/{/g) || []).length -
    (abbreviated.match(/{/g) || []).length;
  const openBrackets =
    (jsonString.match(/\[/g) || []).length -
    (abbreviated.match(/\[/g) || []).length;
  return abbreviated + "}".repeat(openBraces) + "]".repeat(openBrackets);
}

export function logActionWithPayload(
  action: string,
  payloadName: string,
  jsonPayload: unknown
): void {
  const maxPayloadLength = 10000;
  let formattedPayload = prettyJSON(jsonPayload);
  if (formattedPayload.length > maxPayloadLength) {
    formattedPayload = abbreviateJSON(formattedPayload, maxPayloadLength);
  }
  browserLogger.info(
    `Now ${action} ${payloadName} with payload:\n${formattedPayload}`
  );
}

export function transformCreditPackPurchaseRequestResponse(
  result: CreditPackPurchaseRequestResponse
): CreditPackPurchaseRequestResponse {
  const transformedResult = { ...result };
  const fieldsToConvert = [
    "list_of_potentially_agreeing_supernodes",
    "list_of_blacklisted_supernode_pastelids",
    "list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms",
    "list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms_selected_for_signature_inclusion",
    "selected_agreeing_supernodes_signatures_dict",
  ] as const;
  fieldsToConvert.forEach((field) => {
    if (transformedResult[field]) {
      transformedResult[field] = safeStringify(transformedResult[field]);
    }
  });
  return transformedResult;
}

export function computeSHA3256Hexdigest(input: string): string {
  return CryptoJS.SHA3(input, { outputLength: 256 }).toString();
}

export function getSHA256HashOfInputData(inputData: string): string {
  return CryptoJS.SHA256(inputData).toString();
}

export async function compressDataWithZstd(
  inputData: string
): Promise<{ compressedData: Uint8Array; base64EncodedData: string }> {
  const compressedData = pako.deflate(inputData);
  const base64EncodedData = btoa(
    String.fromCharCode.apply(null, Array.from(compressedData))
  );
  return { compressedData, base64EncodedData };
}

export async function decompressDataWithZstd(
  compressedInputData: string
): Promise<string> {
  const binaryString = atob(compressedInputData);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return pako.inflate(bytes, { to: "string" });
}

export async function calculateXORDistance(
  pastelID1: string,
  pastelID2: string
): Promise<bigint> {
  const hash1 = CryptoJS.SHA3(pastelID1, { outputLength: 256 }).toString();
  const hash2 = CryptoJS.SHA3(pastelID2, { outputLength: 256 }).toString();
  const xorResult = BigInt(`0x${hash1}`) ^ BigInt(`0x${hash2}`);
  return xorResult;
}

export function adjustJSONSpacing(jsonString: string): string {
  return jsonString.replace(/(?<!\d):(\s*)/g, ": ").replace(/,(\s*)/g, ", ");
}

export function escapeJsonString(str: string): string {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

export function pythonCompatibleStringify(obj: unknown): string {
  function sortObjectByKeys(
    unsortedObj: Record<string, unknown>
  ): Record<string, unknown> {
    const priorityKeys = ["challenge", "challenge_id", "challenge_signature"];
    return Object.keys(unsortedObj)
      .sort((a, b) => {
        const aPriority = priorityKeys.indexOf(a);
        const bPriority = priorityKeys.indexOf(b);

        if (aPriority !== -1 && bPriority !== -1) {
          return aPriority - bPriority;
        }
        if (aPriority !== -1) {
          return 1;
        }
        if (bPriority !== -1) {
          return -1;
        }
        return a.localeCompare(b);
      })
      .reduce((acc: Record<string, unknown>, key) => {
        const value = unsortedObj[key];
        if (
          typeof value === "object" &&
          value !== null &&
          !(value instanceof Date)
        ) {
          acc[key] = Array.isArray(value)
            ? value.map((item) =>
                sortObjectByKeys(item as Record<string, unknown>)
              )
            : sortObjectByKeys(value as Record<string, unknown>);
        } else {
          acc[key] = value;
        }
        return acc;
      }, {});
  }

  function customReplacer(_key: string, value: unknown): unknown {
    if (value instanceof Date) {
      return value.toISOString();
    }
    if (typeof value === "object" && value !== null) {
      return sortObjectByKeys(value as Record<string, unknown>);
    }
    if (
      typeof value === "string" &&
      value.startsWith("{") &&
      value.endsWith("}")
    ) {
      return escapeJsonString(value);
    }
    if (typeof value === "number") {
      return value;
    }
    return value;
  }
  const sortedObject = sortObjectByKeys(obj as Record<string, unknown>);
  let jsonString = JSON.stringify(sortedObject, customReplacer);
  jsonString = jsonString.replace(/"(true|false)"/g, "$1");
  jsonString = adjustJSONSpacing(jsonString);
  return jsonString;
}

export function base64EncodeJson(jsonInput: string): string {
  return btoa(pythonCompatibleStringify(JSON.parse(jsonInput)));
}

export async function extractResponseFieldsFromCreditPackTicketMessageDataAsJSON(
  modelInstance: Record<string, unknown>
): Promise<string> {
  const responseFields: { [key: string]: unknown } = {};
  const plainObject = modelInstance;

  let lastHashFieldName: string | null = null;
  const lastSignatureFieldNames: string[] = [];
  for (const fieldName in plainObject) {
    if (fieldName.startsWith("sha3_256_hash_of")) {
      lastHashFieldName = fieldName;
    } else if (fieldName.includes("_signature_on_")) {
      lastSignatureFieldNames.push(fieldName);
    }
  }
  Object.keys(plainObject)
    .sort()
    .forEach((fieldName) => {
      if (
        ![
          lastHashFieldName,
          lastSignatureFieldNames[lastSignatureFieldNames.length - 1],
          "id",
          "_changed",
          "_options",
          "_previousDataValues",
          "dataValues",
          "isNewRecord",
          "uniqno",
        ].includes(fieldName)
      ) {
        const fieldValue = plainObject[fieldName];
        if (fieldValue instanceof Date) {
          responseFields[fieldName] = fieldValue.toISOString();
        } else if (typeof fieldValue === "boolean") {
          responseFields[fieldName] = fieldValue ? 1 : 0;
        } else if (typeof fieldValue === "object" && fieldValue !== null) {
          responseFields[fieldName] = pythonCompatibleStringify(fieldValue);
        } else {
          responseFields[fieldName] =
            typeof fieldValue === "number" ? fieldValue : String(fieldValue);
        }
      }
    });
  return pythonCompatibleStringify(responseFields);
}

export async function computeSHA3256HashOfSQLModelResponseFields(
  modelInstance: Record<string, unknown>
): Promise<string> {
  const responseFieldsJSON =
    await extractResponseFieldsFromCreditPackTicketMessageDataAsJSON(
      modelInstance
    );
  const sha256HashOfResponseFields =
    getSHA256HashOfInputData(responseFieldsJSON);
  return sha256HashOfResponseFields;
}

export async function prepareModelForEndpoint<T extends Record<string, unknown>>(
  modelInstance: T
): Promise<Record<string, unknown>> {
  const preparedModelInstance: Record<string, unknown> = {};
  for (const key in modelInstance) {
    if (Object.prototype.hasOwnProperty.call(modelInstance, key)) {
      if (key.endsWith("_json")) {
        if (typeof modelInstance[key] === "string") {
          try {
            const parsedJson = JSON.parse(modelInstance[key] as string);
            preparedModelInstance[key] = pythonCompatibleStringify(parsedJson);
          } catch (e) {
            browserLogger.error(
              `Failed to parse JSON for key: ${key}. Error: ${e}`
            );
            preparedModelInstance[key] = modelInstance[key];
          }
        } else {
          preparedModelInstance[key] = pythonCompatibleStringify(
            modelInstance[key]
          );
        }
      } else {
        preparedModelInstance[key] = modelInstance[key];
      }
    }
  }
  return preparedModelInstance;
}

export function removeSequelizeFields(
  plainObject: Record<string, unknown>
): void {
  const fieldsToRemove = [
    "id",
    "_changed",
    "_options",
    "_previousDataValues",
    "dataValues",
    "isNewRecord",
    "uniqno",
  ];
  Object.keys(plainObject).forEach((fieldName) => {
    if (fieldsToRemove.includes(fieldName)) {
      delete plainObject[fieldName];
    }
  });
}

export async function prepareModelForValidation<T>(modelInstance: Record<string, unknown>): Promise<T> {
  const preparedModelInstance: Record<string, unknown> = {};
  for (const key in modelInstance) {
    if (Object.prototype.hasOwnProperty.call(modelInstance, key)) {
      if (key.endsWith("_json") && typeof modelInstance[key] === "string") {
        try {
          preparedModelInstance[key] = JSON.parse(modelInstance[key] as string);
        } catch (error) {
          console.error(`Error parsing ${key}: ${error}`);
          preparedModelInstance[key] = modelInstance[key];
        }
      } else {
        preparedModelInstance[key] = modelInstance[key];
      }
    }
  }
  return preparedModelInstance as T;
}

export function compareDatetimes(
  datetime1: Date,
  datetime2: Date
): { diffInSeconds: number; areCloseEnough: boolean } {
  const diffInSeconds =
    Math.abs(datetime1.getTime() - datetime2.getTime()) / 1000;
  const areCloseEnough =
    diffInSeconds <=
    MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING;
  return { diffInSeconds, areCloseEnough };
}

export function validateTimestampFields(
  modelInstance: Record<string, unknown>,
  validationErrors: ValidationError[]
): void {
  for (const [fieldName, fieldValue] of Object.entries(modelInstance)) {
    if (fieldName.endsWith("_timestamp_utc_iso_string")) {
      try {
        const timestamp = new Date(fieldValue as string);
        const currentTimestamp = new Date();
        const { areCloseEnough } = compareDatetimes(
          timestamp,
          currentTimestamp
        );
        if (!areCloseEnough) {
          validationErrors.push({
            message: `Timestamp in field ${fieldName} is too far from the current time`,
          });
        }
      } catch {
        validationErrors.push({
          message: `Invalid timestamp format for field ${fieldName}`,
        });
      }
    }
  }
}

export async function validatePastelBlockHeightFields(
  modelInstance: Record<string, unknown>,
  validationErrors: ValidationError[]
): Promise<void> {
  const [, , bestBlockHeight] = await rpc.getBestBlockHashAndMerkleRoot();
  for (const [fieldName, fieldValue] of Object.entries(modelInstance)) {
    if (fieldName.endsWith("_pastel_block_height")) {
      if (
        Math.abs((fieldValue as number) - bestBlockHeight) >
        MAXIMUM_LOCAL_PASTEL_BLOCK_HEIGHT_DIFFERENCE_IN_BLOCKS
      ) {
        validationErrors.push({
          message: `Pastel block height in field ${fieldName} does not match the current block height; difference is ${Math.abs(
            (fieldValue as number) - bestBlockHeight
          )} blocks (local: ${fieldValue}, remote: ${bestBlockHeight})`,
        });
      }
    }
  }
}

export async function validateHashFields(
  modelInstance: Record<string, unknown>,
  validationErrors: ValidationError[]
): Promise<void> {
  const expectedHash = await computeSHA3256HashOfSQLModelResponseFields(
    modelInstance
  );
  let hashFieldName: string | null = null;
  for (const fieldName in modelInstance) {
    if (
      fieldName.includes("sha3_256_hash_of_") &&
      fieldName.endsWith("_fields")
    ) {
      hashFieldName = fieldName;
      break;
    }
  }
  if (hashFieldName) {
    const actualHash = modelInstance[hashFieldName] as string;
    if (actualHash !== expectedHash) {
      validationErrors.push({
        message: `SHA3-256 hash in field ${hashFieldName} does not match the computed hash of the response fields`,
      });
    }
  }
}

export async function getClosestSupernodePastelIDFromList(
  localPastelID: string,
  filteredSupernodes: SupernodeInfo[],
  maxResponseTimeInMilliseconds: number = 800
): Promise<string | null> {
  await clearOldCache();
  if (!filteredSupernodes || filteredSupernodes.length === 0) {
    browserLogger.warn("No filtered supernodes available");
    return null;
  }

  const xorDistances = await Promise.all(
    filteredSupernodes.map(async (supernode) => {
      let pastelID: string;
      if (typeof supernode === "string") {
        pastelID = supernode;
      } else if (supernode && supernode.extKey) {
        pastelID = supernode.extKey;
      } else {
        browserLogger.warn(
          `Invalid supernode data: ${JSON.stringify(supernode)}`
        );
        return null;
      }

      try {
        const startTime = Date.now();
        const distanceResult = await Promise.race([
          calculateXORDistance(localPastelID, pastelID),
          new Promise<null>((_, reject) =>
            setTimeout(() => reject(new Error("XOR calculation timed out")), maxResponseTimeInMilliseconds)
          )
        ]);
        const endTime = Date.now();
        
        if (endTime - startTime > maxResponseTimeInMilliseconds) {
          browserLogger.warn(`XOR calculation for ${pastelID} exceeded time limit`);
          return null;
        }

        if (distanceResult === null) {
          browserLogger.warn(`XOR calculation for ${pastelID} returned null`);
          return null;
        }

        return { pastelID, distance: BigInt(distanceResult) };
      } catch (error) {
        browserLogger.error(
          `Error calculating XOR distance: ${(error as Error).message}`
        );
        return null;
      }
    })
  );

  const validDistances = xorDistances.filter(
    (distance): distance is { pastelID: string; distance: bigint } =>
      distance !== null
  );

  if (validDistances.length === 0) {
    browserLogger.warn("No valid XOR distances calculated");
    return null;
  }

  const sortedXorDistances = validDistances.sort((a, b) => {
    if (a.distance < b.distance) return -1;
    if (a.distance > b.distance) return 1;
    return 0;
  });

  return sortedXorDistances[0].pastelID;
}

export function checkIfPastelIDIsValid(inputString: string): boolean {
  const pattern = /^jX[A-Za-z0-9]{84}$/;
  return pattern.test(inputString);
}

export async function getSupernodeUrlFromPastelID(
  pastelID: string,
  supernodeListDF: SupernodeInfo[]
): Promise<string> {
  const isValidPastelID = checkIfPastelIDIsValid(pastelID);
  if (!isValidPastelID) {
    throw new Error(`Invalid PastelID: ${pastelID}`);
  }
  const supernodeEntry = supernodeListDF.find(
    (node) => node.extKey === pastelID
  );
  if (!supernodeEntry) {
    throw new Error(
      `Supernode with PastelID ${pastelID} not found in the supernode list`
    );
  }
  const ipaddress = supernodeEntry.ipaddress_port.split(":")[0];
  const supernodeURL = `http://${ipaddress}:7123`;
  return supernodeURL;
}

export async function validatePastelIDSignatureFields(
  modelInstance: Record<string, unknown>,
  validationErrors: ValidationError[]
): Promise<void> {
  let lastSignatureFieldName: string | null = null;
  let lastHashFieldName: string | null = null;
  let firstPastelID: string | undefined;
  let pastelID: string;
  let messageToVerify: string;
  let signature: string | undefined;

  const fields = modelInstance;
  for (const fieldName in fields) {
    if (
      fieldName.toLowerCase().includes("_pastelid") &&
      fields[fieldName] !== "NA"
    ) {
      firstPastelID = fields[fieldName] as string;
      break;
    }
  }
  for (const fieldName in fields) {
    if (fieldName.includes("_signature_on_")) {
      lastSignatureFieldName = fieldName;
    } else if (
      fieldName.includes("sha3_256_hash_of_") &&
      fieldName.endsWith("_fields")
    ) {
      lastHashFieldName = fieldName;
    }
  }
  const embeddedField = fields[
    "supernode_pastelid_and_signature_on_inference_request_response_hash"
  ] as string | undefined;
  if (embeddedField) {
    try {
      const parsedData = JSON.parse(embeddedField);
      firstPastelID = parsedData["signing_sn_pastelid"];
      signature = parsedData["sn_signature_on_response_hash"];
    } catch (e) {
      validationErrors.push({
        message:
          "Error parsing JSON from signature field: " + (e as Error).message,
      });
      return;
    }
  }
  if (
    firstPastelID &&
    lastHashFieldName &&
    lastSignatureFieldName
  ) {
    pastelID = firstPastelID;
    messageToVerify = fields[lastHashFieldName] as string;
    if (!embeddedField) {
      signature = fields[lastSignatureFieldName] as string;
    }
    if (signature) {
      const verificationResult = await rpc.verifyMessageWithPastelID(
        pastelID,
        messageToVerify,
        signature
      );
      if (verificationResult !== "OK") {
        validationErrors.push({
          message: `PastelID signature in field ${lastSignatureFieldName} failed verification`,
        });
      }
    } else {
      validationErrors.push({
        message: `Signature is missing`,
      });
    }
  } else {
    validationErrors.push({
      message: `Necessary fields for validation are missing`,
    });
  }
}

export async function getClosestSupernodeToPastelIDURL(
  inputPastelID: string,
  supernodeListDF: SupernodeInfo[],
  maxResponseTimeInMilliseconds: number = 1200
): Promise<{ url: string | null; pastelID: string | null }> {
  browserLogger.info(
    `Attempting to find closest supernode for PastelID: ${inputPastelID}`
  );
  if (!inputPastelID) {
    browserLogger.warn("No input PastelID provided");
    return { url: null, pastelID: null };
  }
  await clearOldCache();
  const filteredSupernodes = await filterSupernodes(
    supernodeListDF,
    maxResponseTimeInMilliseconds
  );
  if (filteredSupernodes.length > 0) {
    const closestSupernodePastelID = await getClosestSupernodePastelIDFromList(
      inputPastelID,
      filteredSupernodes,
      maxResponseTimeInMilliseconds
    );
    if (!closestSupernodePastelID) {
      browserLogger.warn("No closest supernode PastelID found");
      return { url: null, pastelID: null };
    }

    const closestSupernode = supernodeListDF.find(
      (supernode) => supernode.extKey === closestSupernodePastelID
    );

    if (closestSupernode) {
      const supernodeURL = `http://${
        closestSupernode.ipaddress_port.split(":")[0]
      }:7123`;
      try {
        await fetch(supernodeURL, {
          signal: AbortSignal.timeout(maxResponseTimeInMilliseconds),
        });
        return { url: supernodeURL, pastelID: closestSupernodePastelID };
      } catch {
        return { url: null, pastelID: null };
      }
    }
  }
  browserLogger.warn("No filtered supernodes available");
  return { url: null, pastelID: null };
}

export async function getNClosestSupernodesToPastelIDURLs(
  n: number,
  inputPastelID: string,
  supernodeListDF: SupernodeInfo[],
  maxResponseTimeInMilliseconds: number = 800
): Promise<{ url: string; pastelID: string }[]> {
  if (!inputPastelID) {
    browserLogger.warn("No input PastelID provided");
    return [];
  }

  await clearOldCache();

  try {
    const filteredSupernodes = await filterSupernodes(
      supernodeListDF,
      maxResponseTimeInMilliseconds
    );

    if (filteredSupernodes.length === 0) {
      browserLogger.warn("No filtered supernodes available");
      return [];
    }

    const xorDistances = await Promise.all(
      filteredSupernodes.map(async (supernode) => {
        try {
          const distance = await calculateXORDistance(
            inputPastelID,
            supernode.extKey
          );
          return { ...supernode, distance };
        } catch (error) {
          browserLogger.error(
            `Error calculating XOR distance for supernode ${
              supernode.extKey
            }: ${(error as Error).message}`
          );
          return null;
        }
      })
    );

    const validXorDistances = xorDistances.filter(
      (distance): distance is SupernodeWithDistance => distance !== null
    );

    if (validXorDistances.length === 0) {
      browserLogger.warn("No valid XOR distances calculated");
      return [];
    }

    const sortedXorDistances = validXorDistances.sort((a, b) => {
      if (a.distance < b.distance) return -1;
      if (a.distance > b.distance) return 1;
      return 0;
    });

    const closestSupernodes = sortedXorDistances.slice(0, n);

    const validSupernodePromises = closestSupernodes.map(
      async ({ ipaddress_port, extKey }) => {
        const url = `http://${ipaddress_port.split(":")[0]}:7123`;
        try {
          await fetch(url, {
            signal: AbortSignal.timeout(maxResponseTimeInMilliseconds),
          });
          return { url, pastelID: extKey };
        } catch {
          return null;
        }
      }
    );

    const validSupernodes = (await Promise.all(validSupernodePromises)).filter(
      (supernode): supernode is { url: string; pastelID: string } =>
        supernode !== null
    );

    if (validSupernodes.length === 0) {
      browserLogger.warn("No valid supernodes found after connectivity check");
    } else {
      browserLogger.info(`Found ${validSupernodes.length} valid supernodes`);
    }

    return validSupernodes;
  } catch (error) {
    browserLogger.error(
      `Error in getNClosestSupernodesToPastelIDURLs: ${
        (error as Error).message
      }`
    );
    return [];
  }
}

export async function validateCreditPackTicketMessageData(
  modelInstance: Record<string, unknown>
): Promise<ValidationError[]> {
  const validationErrors: ValidationError[] = [];
  validateTimestampFields(modelInstance, validationErrors);
  await validatePastelBlockHeightFields(modelInstance, validationErrors);
  await validateHashFields(modelInstance, validationErrors);
  await validatePastelIDSignatureFields(modelInstance, validationErrors);
  return validationErrors;
}

export function validateInferenceResponseFields(
  responseAuditResults: AuditResult[],
  usageRequestResponse: InferenceAPIUsageResponse
): ValidationResult {
  const inferenceResponseIDCounts: { [key: string]: number } = {};
  const inferenceRequestIDCounts: { [key: string]: number } = {};
  const proposedCostInCreditsCounts: { [key: number]: number } = {};
  const remainingCreditsAfterRequestCounts: { [key: number]: number } = {};
  const creditUsageTrackingPSLAddressCounts: { [key: string]: number } = {};
  const requestConfirmationMessageAmountInPatoshisCounts: { [key: number]: number } = {};
  const maxBlockHeightToIncludeConfirmationTransactionCounts: { [key: number]: number } = {};
  const supernodePastelIDAndSignatureOnInferenceResponseIDCounts: { [key: string]: number } = {};

  for (const result of responseAuditResults) {
    inferenceResponseIDCounts[result.inference_response_id] = (inferenceResponseIDCounts[result.inference_response_id] || 0) + 1;
    inferenceRequestIDCounts[result.inference_request_id] = (inferenceRequestIDCounts[result.inference_request_id] || 0) + 1;
    proposedCostInCreditsCounts[result.proposed_cost_of_request_in_inference_credits] = (proposedCostInCreditsCounts[result.proposed_cost_of_request_in_inference_credits] || 0) + 1;
    remainingCreditsAfterRequestCounts[result.remaining_credits_in_pack_after_request_processed] = (remainingCreditsAfterRequestCounts[result.remaining_credits_in_pack_after_request_processed] || 0) + 1;
    creditUsageTrackingPSLAddressCounts[result.credit_usage_tracking_psl_address] = (creditUsageTrackingPSLAddressCounts[result.credit_usage_tracking_psl_address] || 0) + 1;
    requestConfirmationMessageAmountInPatoshisCounts[result.request_confirmation_message_amount_in_patoshis] = (requestConfirmationMessageAmountInPatoshisCounts[result.request_confirmation_message_amount_in_patoshis] || 0) + 1;
    maxBlockHeightToIncludeConfirmationTransactionCounts[result.max_block_height_to_include_confirmation_transaction] = (maxBlockHeightToIncludeConfirmationTransactionCounts[result.max_block_height_to_include_confirmation_transaction] || 0) + 1;
    supernodePastelIDAndSignatureOnInferenceResponseIDCounts[result.supernode_pastelid_and_signature_on_inference_request_response_hash] = (supernodePastelIDAndSignatureOnInferenceResponseIDCounts[result.supernode_pastelid_and_signature_on_inference_request_response_hash] || 0) + 1;
  }

  const getMajorityValue = <T>(counts: { [key: string]: number }): T => {
    return Object.keys(counts).reduce((a, b) =>
      counts[a] > counts[b] ? a : b
    ) as unknown as T;
  };

  const majorityInferenceResponseID = getMajorityValue<string>(inferenceResponseIDCounts);
  const majorityInferenceRequestID = getMajorityValue<string>(inferenceRequestIDCounts);
  const majorityProposedCostInCredits = getMajorityValue<number>(proposedCostInCreditsCounts);
  const majorityRemainingCreditsAfterRequest = getMajorityValue<number>(remainingCreditsAfterRequestCounts);
  const majorityCreditUsageTrackingPSLAddress = getMajorityValue<string>(creditUsageTrackingPSLAddressCounts);
  const majorityRequestConfirmationMessageAmountInPatoshis = getMajorityValue<number>(requestConfirmationMessageAmountInPatoshisCounts);
  const majorityMaxBlockHeightToIncludeConfirmationTransaction = getMajorityValue<number>(maxBlockHeightToIncludeConfirmationTransactionCounts);
  const majoritySupernodePastelIDAndSignatureOnInferenceResponseID = getMajorityValue<string>(supernodePastelIDAndSignatureOnInferenceResponseIDCounts);

  const validationResults: ValidationResult = {
    inference_result_id: '', // This field is not present in the response validation
    inference_response_id: majorityInferenceResponseID === usageRequestResponse.inference_response_id ? majorityInferenceResponseID : '',
    inference_request_id: majorityInferenceRequestID === usageRequestResponse.inference_request_id ? majorityInferenceRequestID : '',
    proposed_cost_in_credits: majorityProposedCostInCredits === usageRequestResponse.proposed_cost_of_request_in_inference_credits ? majorityProposedCostInCredits : 0,
    remaining_credits_after_request: majorityRemainingCreditsAfterRequest === usageRequestResponse.remaining_credits_in_pack_after_request_processed ? majorityRemainingCreditsAfterRequest : 0,
    credit_usage_tracking_psl_address: majorityCreditUsageTrackingPSLAddress === usageRequestResponse.credit_usage_tracking_psl_address ? majorityCreditUsageTrackingPSLAddress : '',
    request_confirmation_message_amount_in_patoshis: majorityRequestConfirmationMessageAmountInPatoshis === usageRequestResponse.request_confirmation_message_amount_in_patoshis ? majorityRequestConfirmationMessageAmountInPatoshis : 0,
    max_block_height_to_include_confirmation_transaction: majorityMaxBlockHeightToIncludeConfirmationTransaction === usageRequestResponse.max_block_height_to_include_confirmation_transaction ? majorityMaxBlockHeightToIncludeConfirmationTransaction : 0,
    supernode_pastelid_and_signature_on_inference_response_id: majoritySupernodePastelIDAndSignatureOnInferenceResponseID === usageRequestResponse.supernode_pastelid_and_signature_on_inference_request_response_hash ? majoritySupernodePastelIDAndSignatureOnInferenceResponseID : '',
    responding_supernode_pastelid: '', // This field is not present in the response validation
    inference_result_json_base64: '', // This field is not present in the response validation
    inference_result_file_type_strings: '', // This field is not present in the response validation
    responding_supernode_signature_on_inference_result_id: '', // This field is not present in the response validation
  };

  return validationResults;
}

export function validateInferenceResultFields(
  resultAuditResults: AuditResult[],
  usageResult: InferenceAPIOutputResult
): ValidationResult {
  const inferenceResultIDCounts: { [key: string]: number } = {};
  const inferenceRequestIDCounts: { [key: string]: number } = {};
  const inferenceResponseIDCounts: { [key: string]: number } = {};
  const respondingSupernodePastelIDCounts: { [key: string]: number } = {};
  const inferenceResultJSONBase64Counts: { [key: string]: number } = {};
  const inferenceResultFileTypeStringsCounts: { [key: string]: number } = {};
  const respondingSupernodeSignatureOnInferenceResultIDCounts: { [key: string]: number } = {};

  for (const result of resultAuditResults) {
    inferenceResultIDCounts[result.inference_result_id] = (inferenceResultIDCounts[result.inference_result_id] || 0) + 1;
    inferenceRequestIDCounts[result.inference_request_id] = (inferenceRequestIDCounts[result.inference_request_id] || 0) + 1;
    inferenceResponseIDCounts[result.inference_response_id] = (inferenceResponseIDCounts[result.inference_response_id] || 0) + 1;
    respondingSupernodePastelIDCounts[result.responding_supernode_pastelid] = (respondingSupernodePastelIDCounts[result.responding_supernode_pastelid] || 0) + 1;
    inferenceResultJSONBase64Counts[result.inference_result_json_base64.slice(0, 32)] = (inferenceResultJSONBase64Counts[result.inference_result_json_base64.slice(0, 32)] || 0) + 1;
    inferenceResultFileTypeStringsCounts[result.inference_result_file_type_strings] = (inferenceResultFileTypeStringsCounts[result.inference_result_file_type_strings] || 0) + 1;
    respondingSupernodeSignatureOnInferenceResultIDCounts[result.responding_supernode_signature_on_inference_result_id] = (respondingSupernodeSignatureOnInferenceResultIDCounts[result.responding_supernode_signature_on_inference_result_id] || 0) + 1;
  }

  const getMajorityValue = <T>(counts: { [key: string]: number }): T => {
    return Object.keys(counts).reduce((a, b) =>
      counts[a] > counts[b] ? a : b
    ) as unknown as T;
  };

  const majorityInferenceResultID = getMajorityValue<string>(inferenceResultIDCounts);
  const majorityInferenceRequestID = getMajorityValue<string>(inferenceRequestIDCounts);
  const majorityInferenceResponseID = getMajorityValue<string>(inferenceResponseIDCounts);
  const majorityRespondingSupernodePastelID = getMajorityValue<string>(respondingSupernodePastelIDCounts);
  const majorityInferenceResultJSONBase64 = getMajorityValue<string>(inferenceResultJSONBase64Counts);
  const majorityInferenceResultFileTypeStrings = getMajorityValue<string>(inferenceResultFileTypeStringsCounts);
  const majorityRespondingSupernodeSignatureOnInferenceResultID = getMajorityValue<string>(respondingSupernodeSignatureOnInferenceResultIDCounts);

  const validationResults: ValidationResult = {
    inference_result_id: majorityInferenceResultID === usageResult.inference_result_id ? majorityInferenceResultID : '',
    inference_request_id: majorityInferenceRequestID === usageResult.inference_request_id ? majorityInferenceRequestID : '',
    inference_response_id: majorityInferenceResponseID === usageResult.inference_response_id ? majorityInferenceResponseID : '',
    responding_supernode_pastelid: majorityRespondingSupernodePastelID === usageResult.responding_supernode_pastelid ? majorityRespondingSupernodePastelID : '',
    inference_result_json_base64: majorityInferenceResultJSONBase64 === usageResult.inference_result_json_base64.slice(0, 32) ? majorityInferenceResultJSONBase64 : '',
    inference_result_file_type_strings: majorityInferenceResultFileTypeStrings === usageResult.inference_result_file_type_strings ? majorityInferenceResultFileTypeStrings : '',
    responding_supernode_signature_on_inference_result_id: majorityRespondingSupernodeSignatureOnInferenceResultID === usageResult.responding_supernode_signature_on_inference_result_id ? majorityRespondingSupernodeSignatureOnInferenceResultID : '',
    proposed_cost_in_credits: 0, // This field is not present in the result validation
    remaining_credits_after_request: 0, // This field is not present in the result validation
    credit_usage_tracking_psl_address: '', // This field is not present in the result validation
    request_confirmation_message_amount_in_patoshis: 0, // This field is not present in the result validation
    max_block_height_to_include_confirmation_transaction: 0, // This field is not present in the result validation
    supernode_pastelid_and_signature_on_inference_response_id: '', // This field is not present in the result validation
  };

  return validationResults;
}

export function validateInferenceData(
  inferenceResultDict: InferenceResultDict,
  auditResults: AuditResult[]
): ValidationResult {
  const usageRequestResponse = inferenceResultDict.usage_request_response;
  const usageResult = inferenceResultDict.output_results;

  const responseValidationResults = validateInferenceResponseFields(
    auditResults,
    usageRequestResponse
  );

  const resultValidationResults = validateInferenceResultFields(
    auditResults,
    usageResult
  );

  return {
    ...responseValidationResults,
    ...resultValidationResults,
  };
}

export async function filterSupernodes(
  supernodeList: (SupernodeInfo | string)[],
  maxResponseTimeInMilliseconds: number = 700,
  minPerformanceRatio: number = 0.75,
  maxSupernodes: number = 130
): Promise<SupernodeInfo[]> {
  const cacheKey = "filteredSupernodes";

  const stats = {
    totalProcessed: 0,
    removedDueToPing: 0,
    removedDueToPerformance: 0,
    removedDueToError: 0,
    timeouts: 0,
  };

  const logResults = () => {
    const USE_VERBOSE_LOGGING = false;
    const totalRemoved =
      stats.removedDueToPing +
      stats.removedDueToPerformance +
      stats.removedDueToError;
    const removedPercentage = (
      (totalRemoved / stats.totalProcessed) *
      100
    ).toFixed(2);
    if (USE_VERBOSE_LOGGING) {
      browserLogger.info(`Total supernodes processed: ${stats.totalProcessed}`);
      browserLogger.info(
        `Total supernodes removed: ${totalRemoved} (${removedPercentage}%)`
      );
      browserLogger.info(`- Removed due to ping: ${stats.removedDueToPing}`);
      browserLogger.info(
        `- Removed due to performance: ${stats.removedDueToPerformance}`
      );
      browserLogger.info(`- Removed due to errors: ${stats.removedDueToError}`);
      if (stats.timeouts > 0) {
        browserLogger.info(`Total timeouts: ${stats.timeouts}`);
      }
    }
  };

  const cachedData = await getFromCache<SupernodeInfo[]>(cacheKey);

  if (cachedData && cachedData.length >= maxSupernodes) {
    browserLogger.info("Returning cached supernodes.");
    return cachedData.slice(0, maxSupernodes);
  }

  let fullSupernodeList: SupernodeInfo[] = [];
  if (typeof supernodeList[0] === "string") {
    const validMasternodeListFullDF = await rpc.checkSupernodeList();
    fullSupernodeList = validMasternodeListFullDF.validMasternodeListFullDF.filter((supernode: SupernodeInfo) =>
      (supernodeList as string[]).includes(supernode.extKey)
    );
  } else {
    fullSupernodeList = supernodeList as SupernodeInfo[];
  }

  const filteredSupernodes: SupernodeInfo[] = [];
  const completed = false;

  const checkSupernode = async (
    supernode: SupernodeInfo
  ): Promise<SupernodeInfo | null> => {
    stats.totalProcessed++;
    if (completed) return null;
    const cacheKey = `supernode_${supernode.extKey}`;
    const cachedResult = await getFromCache<SupernodeInfo>(cacheKey);

    if (cachedResult) return cachedResult;

    try {
      const ipAddressPort = supernode.ipaddress_port;
      if (!ipAddressPort) return null;
      const ipAddress = ipAddressPort.split(":")[0];

      // Replace ping with a simple fetch request for browser compatibility
      const pingStart = performance.now();
      try {
        await fetch(`http://${ipAddress}:7123/ping`, {
          signal: AbortSignal.timeout(maxResponseTimeInMilliseconds),
        });
      } catch {
        stats.removedDueToPing++;
        return null;
      }
      const pingTime = performance.now() - pingStart;

      if (pingTime > maxResponseTimeInMilliseconds) {
        stats.removedDueToPing++;
        return null;
      }

      const performanceResponse = await fetch(
        `http://${ipAddress}:7123/liveness_ping`,
        {
          signal: AbortSignal.timeout(maxResponseTimeInMilliseconds),
        }
      );
      const performanceData = await performanceResponse.json();
      if (performanceData.performance_ratio_score < minPerformanceRatio) {
        stats.removedDueToPerformance++;
        return null;
      }
      const result: SupernodeInfo = {
        ...supernode,
        url: `http://${ipAddress}:7123`,
      };
      await storeInCache(cacheKey, result);
      return result;
    } catch {
      stats.removedDueToError++;
      return null;
    }
  };

  const promises = fullSupernodeList.map(checkSupernode);
  const results = await Promise.all(promises);
  filteredSupernodes.push(
    ...results.filter((result): result is SupernodeInfo => result !== null)
  );

  await storeInCache(cacheKey, filteredSupernodes);
  logResults();
  return filteredSupernodes.slice(0, maxSupernodes);
}

type CheckFunction = (arg: string) => Promise<boolean>;
interface ConfirmationOptions {
  maxRetries: number;
  retryDelay: number;
  actionName: string;
}

export async function waitForConfirmation(
  checkFunction: CheckFunction,
  arg: string,
  options?: Partial<ConfirmationOptions>
): Promise<boolean> {
  const defaultOptions: ConfirmationOptions = {
    maxRetries: 30,
    retryDelay: 10000,
    actionName: "condition",
  };
  const finalOptions = { ...defaultOptions, ...options };

  for (let attempt = 1; attempt <= finalOptions.maxRetries; attempt++) {
    try {
      const result = await checkFunction(arg);
      if (result) {
        browserLogger.info(
          `${finalOptions.actionName} confirmed after ${attempt} attempt(s).`
        );
        return true;
      }
    } catch (error) {
      browserLogger.warn(
        `Error checking ${finalOptions.actionName} (attempt ${attempt}/${
          finalOptions.maxRetries
        }): ${(error as Error).message}`
      );
    }

    if (attempt < finalOptions.maxRetries) {
      browserLogger.info(
        `${finalOptions.actionName} not yet confirmed. Attempt ${attempt}/${
          finalOptions.maxRetries
        }. Waiting ${finalOptions.retryDelay / 1000} seconds before next check...`
      );
      await new Promise((resolve) => setTimeout(resolve, finalOptions.retryDelay));
    }
  }

  browserLogger.warn(
    `${finalOptions.actionName} not confirmed after ${finalOptions.maxRetries} attempts.`
  );
  return false;
}

export async function waitForPastelIDRegistration(
  pastelID: string
): Promise<boolean> {
  const isRegistered = await waitForConfirmation(
    rpc.isPastelIDRegistered,
    pastelID,
    {
      maxRetries: 20,
      retryDelay: 15000,
      actionName: "PastelID registration",
    }
  );

  if (isRegistered) {
    browserLogger.info(
      `PastelID ${pastelID} has been successfully registered.`
    );
  } else {
    browserLogger.error(
      `PastelID ${pastelID} registration could not be confirmed.`
    );
  }

  return isRegistered;
}

export async function waitForCreditPackConfirmation(
  txid: string
): Promise<boolean> {
  const isConfirmed = await waitForConfirmation(
    rpc.isCreditPackConfirmed,
    txid,
    {
      maxRetries: 40,
      retryDelay: 20000,
      actionName: "Credit pack confirmation",
    }
  );

  if (isConfirmed) {
    browserLogger.info(`Credit pack with TXID ${txid} has been confirmed.`);
  } else {
    browserLogger.error(
      `Credit pack with TXID ${txid} could not be confirmed.`
    );
  }

  return isConfirmed;
}

export async function importPromotionalPack(jsonData: string): Promise<{
  success: boolean;
  message: string;
  processedPacks?: { pub_key: string; passphrase: string }[];
}> {
  browserLogger.info(`Starting import of promotional pack`);
  const processedPacks: { pub_key: string; passphrase: string }[] = [];

  try {
    // Initialize WASM
    browserLogger.info("Initializing WASM...");
    await rpc.initialize();
    browserLogger.info("WASM initialized successfully");

    // Parse the JSON data
    let packData: { 
      pastel_id_pubkey: string; 
      pastel_id_passphrase: string;
      secureContainerBase64: string; 
      requested_initial_credits_in_credit_pack: number;
      psl_credit_usage_tracking_address: string;
      psl_credit_usage_tracking_address_private_key: string;
    }[] = JSON.parse(jsonData);
    if (!Array.isArray(packData)) {
      packData = [packData];
    }

    for (let i = 0; i < packData.length; i++) {
      const pack = packData[i];
      browserLogger.info(`Processing pack ${i + 1} of ${packData.length}`);

      // 1. Save the PastelID secure container
      const network = await storage.getNetworkFromLocalStorage();
      await storage.storeSecureContainer(
        pack.pastel_id_pubkey,
        pack.secureContainerBase64,
        network
      );

      // 2. Import the tracking address private key
      browserLogger.info(
        `Importing private key for tracking address: ${pack.psl_credit_usage_tracking_address}`
      );

      const importResult = await rpc.importPrivKey(
        pack.psl_credit_usage_tracking_address_private_key,
        "Imported from promotional pack",
        true
      );
      if (importResult) {
        browserLogger.info(
          `Private key imported successfully for tracking address: ${importResult}`
        );
      } else {
        browserLogger.warn("Failed to import private key");
      }

      // 3. Log other important information
      browserLogger.info(`PastelID: ${pack.pastel_id_pubkey}`);
      browserLogger.info(`Passphrase: ${pack.pastel_id_passphrase}`);
      browserLogger.info(
        `Credit Pack Ticket: ${JSON.stringify(pack, null, 2)}`
      );

      processedPacks.push({
        pub_key: pack.pastel_id_pubkey,
        passphrase: pack.pastel_id_passphrase,
      });

      browserLogger.info(`Pack ${i + 1} processed successfully`);
    }

    // Verify PastelID import and functionality
    for (let i = 0; i < packData.length; i++) {
      const pack = packData[i];
      browserLogger.info(`Verifying PastelID import for pack ${i + 1}`);

      try {
        // Verify PastelID functionality
        const testMessage = "This is a test message for PastelID verification";
        const signature = await rpc.signMessageWithPastelID(
          pack.pastel_id_pubkey,
          testMessage,
          pack.pastel_id_passphrase
        );
        browserLogger.info(
          `Signature created successfully for PastelID: ${pack.pastel_id_pubkey}`
        );

        const verificationResult = await rpc.verifyMessageWithPastelID(
          pack.pastel_id_pubkey,
          testMessage,
          signature
        );

        if (verificationResult) {
          browserLogger.info(
            `PastelID ${pack.pastel_id_pubkey} verified successfully`
          );
        } else {
          browserLogger.warn(
            `PastelID ${pack.pastel_id_pubkey} verification failed`
          );
        }

        // We can't wait for blockchain confirmation in browser context,
        // so we'll just log that we've processed the credit pack ticket
        browserLogger.info(
          `Credit Pack Ticket for ${pack.requested_initial_credits_in_credit_pack} credits processed`
        );
      } catch (error) {
        browserLogger.error(
          `Error verifying pack ${i + 1}: ${(error as Error).message}`
        );
      }
    }

    browserLogger.info(
      "All promo packs in the file have been processed and verified"
    );
    return {
      success: true,
      message: "Promotional pack(s) imported and verified successfully",
      processedPacks: processedPacks,
    };
  } catch (error) {
    browserLogger.error(
      `Error importing promotional pack: ${(error as Error).message}`
    );
    return {
      success: false,
      message: `Failed to import promotional pack: ${(error as Error).message}`,
    };
  }
}

// Export all functions
const utils  = {
  safeStringify,
  clearOldCache,
  storeInCache,
  getFromCache,
  fetchCurrentPSLMarketPrice,
  estimatedMarketPriceOfInferenceCreditsInPSLTerms,
  parseAndFormat,
  prettyJSON,
  abbreviateJSON,
  logActionWithPayload,
  transformCreditPackPurchaseRequestResponse,
  computeSHA3256Hexdigest,
  getSHA256HashOfInputData,
  compressDataWithZstd,
  decompressDataWithZstd,
  calculateXORDistance,
  adjustJSONSpacing,
  escapeJsonString,
  pythonCompatibleStringify,
  base64EncodeJson,
  extractResponseFieldsFromCreditPackTicketMessageDataAsJSON,
  computeSHA3256HashOfSQLModelResponseFields,
  prepareModelForEndpoint,
  removeSequelizeFields,
  prepareModelForValidation,
  compareDatetimes,
  validateTimestampFields,
  validatePastelBlockHeightFields,
  validateHashFields,
  getClosestSupernodePastelIDFromList,
  checkIfPastelIDIsValid,
  getSupernodeUrlFromPastelID,
  validatePastelIDSignatureFields,
  getClosestSupernodeToPastelIDURL,
  getNClosestSupernodesToPastelIDURLs,
  validateCreditPackTicketMessageData,
  validateInferenceResponseFields,
  validateInferenceResultFields,
  validateInferenceData,
  filterSupernodes,
  waitForConfirmation,
  waitForPastelIDRegistration,
  waitForCreditPackConfirmation,
  importPromotionalPack,
};

export default utils;

---
./src/app/lib/cache.ts
---
// src/app/lib/cache.ts

'use client'

export class Cache<T> {
    private static instance: Cache<unknown>;
    private cache: Map<string, { data: T; timestamp: number }> = new Map();
  
    private constructor() {}
  
    static getInstance<U>(): Cache<U> {
      if (!Cache.instance) {
        Cache.instance = new Cache<U>();
      }
      return Cache.instance as Cache<U>;
    }
  
    set(key: string, value: T, ttl: number = 60000): void {
      this.cache.set(key, { data: value, timestamp: Date.now() + ttl });
    }
  
    get(key: string): T | null {
      const item = this.cache.get(key);
      if (item && item.timestamp > Date.now()) {
        return item.data;
      }
      this.cache.delete(key);
      return null;
    }
  
    delete(key: string): void {
      this.cache.delete(key);
    }
  
    clear(): void {
      this.cache.clear();
    }

    findAll(): string[] {
      return Array.from(this.cache.keys());
    }

    findByPk(key: string): { data: T; timestamp: number } | undefined {
      return this.cache.get(key);
    }

    destroy(options: { where: { key: string } }): void {
      this.cache.delete(options.where.key);
    }
}
  
export const cacheInstance = Cache.getInstance<unknown>();

---
./src/app/lib/validationSchemas.ts
---
// src/lib/validationSchemas.ts

import { z } from 'zod';

// Helper function to create a UUID validator
const uuidv4 = () => z.string().uuid();

export const supernodeListSchema = z.object({
  txid_vout: z.string(),
  supernode_status: z.string(),
  protocol_version: z.number(),
  supernode_psl_address: z.string(),
  lastseentime: z.number(),
  activeseconds: z.number(),
  activedays: z.number(),
  lastpaidtime: z.number(),
  lastpaidblock: z.number(),
  ipaddress_port: z.string(),
  rank: z.number(),
  pubkey: z.string(),
  extAddress: z.string(),
  extP2P: z.string(),
  extKey: z.string(),
});

export const messageSchema = z.object({
  id: uuidv4(),
  sending_sn_pastelid: z.string(),
  receiving_sn_pastelid: z.string(),
  sending_sn_txid_vout: z.string(),
  receiving_sn_txid_vout: z.string(),
  message_type: z.string(),
  message_body: z.string(),
  signature: z.string(),
  timestamp: z.string().datetime(),
});

export const userMessageSchema = z.object({
  id: uuidv4(),
  from_pastelid: z.string(),
  to_pastelid: z.string(),
  message_body: z.string(),
  message_signature: z.string(),
  timestamp: z.string().datetime(),
});

export const creditPackPurchaseRequestSchema = z.object({
  id: uuidv4(),
  requesting_end_user_pastelid: z.string(),
  requested_initial_credits_in_credit_pack: z.number().int(),
  list_of_authorized_pastelids_allowed_to_use_credit_pack: z.string(),
  credit_usage_tracking_psl_address: z.string(),
  request_timestamp_utc_iso_string: z.string(),
  request_pastel_block_height: z.number().int(),
  credit_purchase_request_message_version_string: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  requesting_end_user_pastelid_signature_on_request_hash: z.string(),
});

export const creditPackPurchaseRequestRejectionSchema = z.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  credit_pack_purchase_request_fields_json_b64: z.string(),
  rejection_reason_string: z.string(),
  rejection_timestamp_utc_iso_string: z.string(),
  rejection_pastel_block_height: z.number().int(),
  credit_purchase_request_rejection_message_version_string: z.string(),
  responding_supernode_pastelid: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_rejection_fields: z.string(),
  responding_supernode_signature_on_credit_pack_purchase_request_rejection_hash: z.string(),
});

export const creditPackPurchaseRequestPreliminaryPriceQuoteSchema = z.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  credit_usage_tracking_psl_address: z.string(),
  credit_pack_purchase_request_fields_json_b64: z.string(),
  preliminary_quoted_price_per_credit_in_psl: z.number(),
  preliminary_total_cost_of_credit_pack_in_psl: z.number(),
  preliminary_price_quote_timestamp_utc_iso_string: z.string(),
  preliminary_price_quote_pastel_block_height: z.number().int(),
  preliminary_price_quote_message_version_string: z.string(),
  responding_supernode_pastelid: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields: z.string(),
  responding_supernode_signature_on_credit_pack_purchase_request_preliminary_price_quote_hash: z.string(),
});

export const creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema = z.object({
  id: uuidv4(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields: z.string(),
  credit_pack_purchase_request_fields_json_b64: z.string(),
  agree_with_preliminary_price_quote: z.boolean(),
  credit_usage_tracking_psl_address: z.string(),
  preliminary_quoted_price_per_credit_in_psl: z.number(),
  preliminary_price_quote_response_timestamp_utc_iso_string: z.string(),
  preliminary_price_quote_response_pastel_block_height: z.number().int(),
  preliminary_price_quote_response_message_version_string: z.string(),
  requesting_end_user_pastelid: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields: z.string(),
  requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash: z.string(),
});

export const creditPackPurchaseRequestResponseTerminationSchema = z.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  credit_pack_purchase_request_fields_json_b64: z.string(),
  termination_reason_string: z.string(),
  termination_timestamp_utc_iso_string: z.string(),
  termination_pastel_block_height: z.number().int(),
  credit_purchase_request_termination_message_version_string: z.string(),
  responding_supernode_pastelid: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_termination_fields: z.string(),
  responding_supernode_signature_on_credit_pack_purchase_request_termination_hash: z.string(),
});

export const creditPackPurchaseRequestResponseSchema = z.object({
  id: uuidv4(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  credit_pack_purchase_request_fields_json_b64: z.string(),
  psl_cost_per_credit: z.number(),
  proposed_total_cost_of_credit_pack_in_psl: z.number(),
  credit_usage_tracking_psl_address: z.string(),
  request_response_timestamp_utc_iso_string: z.string(),
  request_response_pastel_block_height: z.number().int(),
  best_block_merkle_root: z.string(),
  best_block_height: z.number().int(),
  credit_purchase_request_response_message_version_string: z.string(),
  responding_supernode_pastelid: z.string(),
  list_of_blacklisted_supernode_pastelids: z.string(),
  list_of_potentially_agreeing_supernodes: z.string(),
  list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms: z.string(),
  list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms_selected_for_signature_inclusion: z.string(),
  selected_agreeing_supernodes_signatures_dict: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: z.string(),
  responding_supernode_signature_on_credit_pack_purchase_request_response_hash: z.string(),
});

export const creditPackPurchaseRequestConfirmationSchema = z.object({
  id: uuidv4(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: z.string(),
  credit_pack_purchase_request_fields_json_b64: z.string(),
  requesting_end_user_pastelid: z.string(),
  txid_of_credit_purchase_burn_transaction: z.string(),
  credit_purchase_request_confirmation_utc_iso_string: z.string(),
  credit_purchase_request_confirmation_pastel_block_height: z.number().int(),
  credit_purchase_request_confirmation_message_version_string: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: z.string(),
  requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: z.string(),
});

export const creditPackPurchaseRequestConfirmationResponseSchema = z.object({
  id: uuidv4(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: z.string(),
  credit_pack_confirmation_outcome_string: z.string(),
  pastel_api_credit_pack_ticket_registration_txid: z.string(),
  credit_pack_confirmation_failure_reason_if_applicable: z.string().nullable(),
  credit_purchase_request_confirmation_response_utc_iso_string: z.string(),
  credit_purchase_request_confirmation_response_pastel_block_height: z.number().int(),
  credit_purchase_request_confirmation_response_message_version_string: z.string(),
  responding_supernode_pastelid: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_response_fields: z.string(),
  responding_supernode_signature_on_credit_pack_purchase_request_confirmation_response_hash: z.string(),
});

export const creditPackRequestStatusCheckSchema = z.object({
  id: uuidv4(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  requesting_end_user_pastelid: z.string(),
  requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
});

export const creditPackPurchaseRequestStatusSchema = z.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: z.string(),
  status: z.string(),
  status_details: z.string(),
  status_update_timestamp_utc_iso_string: z.string(),
  status_update_pastel_block_height: z.number().int(),
  credit_purchase_request_status_message_version_string: z.string(),
  responding_supernode_pastelid: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_status_fields: z.string(),
  responding_supernode_signature_on_credit_pack_purchase_request_status_hash: z.string(),
});

export const creditPackStorageRetryRequestSchema = z.object({
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: z.string(),
  credit_pack_purchase_request_fields_json_b64: z.string(),
  requesting_end_user_pastelid: z.string(),
  closest_agreeing_supernode_to_retry_storage_pastelid: z.string(),
  credit_pack_storage_retry_request_timestamp_utc_iso_string: z.string(),
  credit_pack_storage_retry_request_pastel_block_height: z.number().int(),
  credit_pack_storage_retry_request_message_version_string: z.string(),
  sha3_256_hash_of_credit_pack_storage_retry_request_fields: z.string(),
  requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash: z.string(),
});

export const creditPackStorageRetryRequestResponseSchema = z.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: z.string(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: z.string(),
  credit_pack_storage_retry_confirmation_outcome_string: z.string(),
  pastel_api_credit_pack_ticket_registration_txid: z.string(),
  credit_pack_storage_retry_confirmation_failure_reason_if_applicable: z.string(),
  credit_pack_storage_retry_confirmation_response_utc_iso_string: z.string(),
  credit_pack_storage_retry_confirmation_response_pastel_block_height: z.number().int(),
  credit_pack_storage_retry_confirmation_response_message_version_string: z.string(),
  closest_agreeing_supernode_to_retry_storage_pastelid: z.string(),
  sha3_256_hash_of_credit_pack_storage_retry_confirmation_response_fields: z.string(),
  closest_agreeing_supernode_to_retry_storage_pastelid_signature_on_credit_pack_storage_retry_confirmation_response_hash: z.string(),
});

export const inferenceAPIUsageRequestSchema = z.object({
  inference_request_id: uuidv4(),
  requesting_pastelid: z.string(),
  credit_pack_ticket_pastel_txid: z.string(),
  requested_model_canonical_string: z.string(),
  model_inference_type_string: z.string(),
  model_parameters_json_b64: z.string(),
  model_input_data_json_b64: z.string(),
  inference_request_utc_iso_string: z.string(),
  inference_request_pastel_block_height: z.number().int(),
  status: z.string(),
  inference_request_message_version_string: z.string(),
  sha3_256_hash_of_inference_request_fields: z.string(),
  requesting_pastelid_signature_on_request_hash: z.string(),
});

export const inferenceAPIUsageResponseSchema = z.object({
  inference_response_id: uuidv4(),
  inference_request_id: z.string(),
  proposed_cost_of_request_in_inference_credits: z.number(),
  remaining_credits_in_pack_after_request_processed: z.number(),
  credit_usage_tracking_psl_address: z.string(),
  request_confirmation_message_amount_in_patoshis: z.number().int(),
  max_block_height_to_include_confirmation_transaction: z.number().int(),
  inference_request_response_utc_iso_string: z.string(),
  inference_request_response_pastel_block_height: z.number().int(),
  inference_request_response_message_version_string: z.string(),
  sha3_256_hash_of_inference_request_response_fields: z.string(),
  supernode_pastelid_and_signature_on_inference_request_response_hash: z.string(),
});

export const inferenceAPIOutputResultSchema = z.object({
    inference_result_id: uuidv4(),
    inference_request_id: z.string(),
    inference_response_id: z.string(),
    responding_supernode_pastelid: z.string(),
    inference_result_json_base64: z.string(),
    inference_result_file_type_strings: z.string(),
    inference_result_utc_iso_string: z.string(),
    inference_result_pastel_block_height: z.number().int(),
    inference_result_message_version_string: z.string(),
    sha3_256_hash_of_inference_result_fields: z.string(),
    responding_supernode_signature_on_inference_result_id: z.string(),
  });
  
  export const inferenceConfirmationSchema = z.object({
    inference_request_id: z.string(),
    requesting_pastelid: z.string(),
    confirmation_transaction: z.object({
      txid: z.string(),
    }),
  });
  
  // Utility function to validate data against a schema
  export async function validateSchema<T>(schema: z.ZodSchema<T>, data: unknown): Promise<{ isValid: boolean; errors: string[] | null; data: T | null }> {
    try {
      const validatedData = await schema.parseAsync(data);
      return { isValid: true, errors: null, data: validatedData };
    } catch (error) {
      if (error instanceof z.ZodError) {
        return { isValid: false, errors: error.errors.map(e => e.message), data: null };
      }
      throw error;
    }
  }
  
  // Type exports
  export type SupernodeList = z.infer<typeof supernodeListSchema>;
  export type Message = z.infer<typeof messageSchema>;
  export type UserMessage = z.infer<typeof userMessageSchema>;
  export type CreditPackPurchaseRequest = z.infer<typeof creditPackPurchaseRequestSchema>;
  export type CreditPackPurchaseRequestRejection = z.infer<typeof creditPackPurchaseRequestRejectionSchema>;
  export type CreditPackPurchaseRequestPreliminaryPriceQuote = z.infer<typeof creditPackPurchaseRequestPreliminaryPriceQuoteSchema>;
  export type CreditPackPurchaseRequestPreliminaryPriceQuoteResponse = z.infer<typeof creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema>;
  export type CreditPackPurchaseRequestResponseTermination = z.infer<typeof creditPackPurchaseRequestResponseTerminationSchema>;
  export type CreditPackPurchaseRequestResponse = z.infer<typeof creditPackPurchaseRequestResponseSchema>;
  export type CreditPackPurchaseRequestConfirmation = z.infer<typeof creditPackPurchaseRequestConfirmationSchema>;
  export type CreditPackPurchaseRequestConfirmationResponse = z.infer<typeof creditPackPurchaseRequestConfirmationResponseSchema>;
  export type CreditPackRequestStatusCheck = z.infer<typeof creditPackRequestStatusCheckSchema>;
  export type CreditPackPurchaseRequestStatus = z.infer<typeof creditPackPurchaseRequestStatusSchema>;
  export type CreditPackStorageRetryRequest = z.infer<typeof creditPackStorageRetryRequestSchema>;
  export type CreditPackStorageRetryRequestResponse = z.infer<typeof creditPackStorageRetryRequestResponseSchema>;
  export type InferenceAPIUsageRequest = z.infer<typeof inferenceAPIUsageRequestSchema>;
  export type InferenceAPIUsageResponse = z.infer<typeof inferenceAPIUsageResponseSchema>;
  export type InferenceAPIOutputResult = z.infer<typeof inferenceAPIOutputResultSchema>;
  export type InferenceConfirmation = z.infer<typeof inferenceConfirmationSchema>;

---
./src/app/lib/endToEndFunctions.ts
---
// src/app/lib/endToEndFunctions.ts

'use client'

import BrowserRPCReplacement from "@/app/lib/BrowserRPCReplacement";
import { BrowserDatabase } from "@/app/lib/BrowserDatabase";
import PastelInferenceClient from "@/app/lib/PastelInferenceClient";
import * as utils from "./utils";
import * as schemas from "./validationSchemas";
import browserLogger from "@/app/lib/logger";
import pastelGlobals from "@/app/lib/globals";

import {
  CreditPack,
  CreditPackTicketInfo,
  InferenceRequestParams,
  InferenceResult,
  CreditPackCreationResult,
  SupernodeURL,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestResponse,
  SupernodeInfo,
  InferenceAPIUsageRequest,
  InferenceConfirmation,
  UserMessage,
  CreditPackStorageRetryRequest,
  CreditPackStorageRetryRequestResponse,
} from "@/app/types";

const rpc = new BrowserRPCReplacement();
const db = new BrowserDatabase();

function getIsoStringWithMicroseconds(): string {
  const now = new Date();
  return now.toISOString().replace("Z", "+00:00").replace(/\s/g, "");
}

export async function checkForNewIncomingMessages(): Promise<UserMessage[]> {
  try {
    const pastelID = pastelGlobals.getPastelId();
    const passphrase = pastelGlobals.getPassphrase();

    if (!pastelID || !passphrase) {
      browserLogger.error("PastelID or passphrase is not set");
      return [];
    }

    const inferenceClient = new PastelInferenceClient({ pastelID, passphrase });
    const { validMasternodeListFullDF } = await rpc.checkSupernodeList();

    browserLogger.info(`My local pastelid: ${inferenceClient.getPastelID()}`);

    const closestSupernodesToLocal =
      await utils.getNClosestSupernodesToPastelIDURLs(
        3,
        inferenceClient.getPastelID(),
        validMasternodeListFullDF
      );
    browserLogger.info(
      `Closest Supernodes to local pastelid: ${closestSupernodesToLocal
        .map((sn) => `PastelID: ${sn.pastelID}, URL: ${sn.url}`)
        .join(", ")}`
    );

    const messageRetrievalTasks = closestSupernodesToLocal.map(({ url }) =>
      inferenceClient.getUserMessages(url).catch((error) => {
        browserLogger.warn(
          `Failed to retrieve messages from supernode ${url}: ${error.message}`
        );
        return [];
      })
    );
    const messageLists = await Promise.all(messageRetrievalTasks);

    const uniqueMessages: UserMessage[] = [];
    const messageIDs = new Set<string>();
    for (const messageList of messageLists) {
      for (const message of messageList) {
        if (message.id && !messageIDs.has(message.id)) {
          uniqueMessages.push(message);
          messageIDs.add(message.id);
        }
      }
    }

    return uniqueMessages;
  } catch (error) {
    browserLogger.error(
      `Error in checkForNewIncomingMessages: ${(error as Error).message}`
    );
    throw error;
  }
}

export async function sendMessageAndCheckForNewIncomingMessages(
  toPastelID: string,
  messageBody: string
): Promise<{ sent_messages: UserMessage[]; received_messages: UserMessage[] }> {
  try {
    const pastelID = pastelGlobals.getPastelId();
    const passphrase = pastelGlobals.getPassphrase();

    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }

    const inferenceClient = new PastelInferenceClient({ pastelID, passphrase });
    const { validMasternodeListFullDF } = await rpc.checkSupernodeList();

    browserLogger.info("Sending user message...");
    browserLogger.info(`Recipient pastelid: ${toPastelID}`);

    const closestSupernodesToRecipient =
      await utils.getNClosestSupernodesToPastelIDURLs(
        3,
        toPastelID,
        validMasternodeListFullDF
      );
    browserLogger.info(
      `Closest Supernodes to recipient pastelid: ${closestSupernodesToRecipient.map(
        (sn) => sn.pastelID
      )}`
    );

    const userMessage: UserMessage = {
      from_pastelid: pastelID,
      to_pastelid: toPastelID,
      message_body: utils.safeStringify(messageBody),
      message_signature: await rpc.signMessageWithPastelID(
        pastelID,
        messageBody,
        passphrase
      ),
      timestamp: new Date().toISOString(),
      id: ""
    };

    const { error } = schemas.userMessageSchema.safeParse(userMessage);
    if (error) {
      throw new Error(`Invalid user message: ${error.message}`);
    }

    const sendTasks = closestSupernodesToRecipient.map(({ url }) =>
      inferenceClient.sendUserMessage(url, userMessage)
    );

    const sendResults = await Promise.all(sendTasks);

    browserLogger.info(
      `Sent user messages: ${utils.safeStringify(sendResults)}`
    );

    const receivedMessages = await checkForNewIncomingMessages();


    return {
      sent_messages: sendResults,
      received_messages: receivedMessages,
    };
  } catch (error) {
    browserLogger.error(
      `Error in sendMessageAndCheckForNewIncomingMessages: ${
        (error as Error).message
      }`
    );
    throw error;
  }
}

export async function handleCreditPackTicketEndToEnd(
  numberOfCredits: number,
  creditUsageTrackingPSLAddress: string,
  burnAddress: string,
  maximumTotalCreditPackPriceInPSL: number,
  maximumPerCreditPriceInPSL: number,
  optionalPastelID?: string,
  optionalPassphrase?: string
): Promise<CreditPackCreationResult> {
  let pastelID: string, passphrase: string;

  if (optionalPastelID && optionalPassphrase) {
    pastelID = optionalPastelID;
    passphrase = optionalPassphrase;
  } else {
    pastelID = pastelGlobals.getPastelId() || "";
    passphrase = pastelGlobals.getPassphrase() || "";
  }

  if (!pastelID || !passphrase) {
    throw new Error("PastelID or passphrase is not set");
  }

  const inferenceClient = new PastelInferenceClient({ pastelID, passphrase });

  try {
    const { validMasternodeListFullDF } = await rpc.checkSupernodeList();
    const requestTimestamp = getIsoStringWithMicroseconds();

    const creditPackRequest: CreditPackPurchaseRequest = {
      requesting_end_user_pastelid: pastelID,
      requested_initial_credits_in_credit_pack: numberOfCredits,
      list_of_authorized_pastelids_allowed_to_use_credit_pack: JSON.stringify([
        pastelID,
      ]),
      credit_usage_tracking_psl_address: creditUsageTrackingPSLAddress,
      request_timestamp_utc_iso_string: requestTimestamp,
      request_pastel_block_height: await rpc.getCurrentPastelBlockHeight(),
      credit_purchase_request_message_version_string: "1.0",
      sha3_256_hash_of_credit_pack_purchase_request_fields: "",
      requesting_end_user_pastelid_signature_on_request_hash: "",
    };

    creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields =
      await utils.computeSHA3256HashOfSQLModelResponseFields(creditPackRequest);
    creditPackRequest.requesting_end_user_pastelid_signature_on_request_hash =
      await rpc.signMessageWithPastelID(
        pastelID,
        creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
        passphrase
      );

    const closestSupernodes = await utils.getNClosestSupernodesToPastelIDURLs(
      12,
      pastelID,
      validMasternodeListFullDF
    );
    if (closestSupernodes.length === 0) {
      throw new Error("No responsive supernodes found.");
    }

    for (const supernode of closestSupernodes) {
      try {
        browserLogger.info(
          `Attempting credit pack request with supernode: ${supernode.url}`
        );

        const preliminaryPriceQuote =
          await inferenceClient.creditPackTicketInitialPurchaseRequest(
            supernode.url,
            creditPackRequest
          );

        if ("rejection_reason_string" in preliminaryPriceQuote) {
          browserLogger.info(
            `Credit pack purchase request rejected: ${preliminaryPriceQuote.rejection_reason_string}`
          );
          continue;
        }

        const signedCreditPackTicketOrRejection =
          await inferenceClient.creditPackTicketPreliminaryPriceQuoteResponse(
            supernode.url,
            creditPackRequest,
            preliminaryPriceQuote,
            maximumTotalCreditPackPriceInPSL,
            maximumPerCreditPriceInPSL
          );

        if ("termination_reason_string" in signedCreditPackTicketOrRejection) {
          browserLogger.info(
            `Credit pack purchase request terminated: ${signedCreditPackTicketOrRejection.termination_reason_string}`
          );
          continue;
        }

        const signedCreditPackTicket =
          signedCreditPackTicketOrRejection as CreditPackPurchaseRequestResponse;

        const burnTransactionResponse = await rpc.sendToAddress(
          burnAddress,
          Math.round(
            signedCreditPackTicket.proposed_total_cost_of_credit_pack_in_psl *
              100000
          ) / 100000,
        );

        if (!burnTransactionResponse) {
          throw new Error(`Error sending PSL to burn address`);
        }

        const burnTransactionTxid = burnTransactionResponse;

        const creditPackPurchaseRequestConfirmation =
          await buildCreditPackPurchaseRequestConfirmation(
            creditPackRequest,
            signedCreditPackTicket,
            burnTransactionTxid,
            pastelID,
            passphrase
          );

        await db.addData(
          "CreditPackPurchaseRequestConfirmation",
          creditPackPurchaseRequestConfirmation
        );

        const creditPackPurchaseRequestConfirmationResponse =
          await inferenceClient.confirmCreditPurchaseRequest(
            supernode.url,
            creditPackPurchaseRequestConfirmation
          );

        if (!creditPackPurchaseRequestConfirmationResponse) {
          throw new Error("Credit pack ticket storage failed");
        }

        const creditPackPurchaseRequestStatus =
          await checkCreditPackPurchaseRequestStatus(
            inferenceClient,
            supernode.url,
            creditPackRequest,
            closestSupernodes
          );

        if (creditPackPurchaseRequestStatus.status !== "completed") {
          const creditPackStorageRetryRequestResponse =
            await initiateStorageRetry(
              inferenceClient,
              creditPackRequest,
              signedCreditPackTicket,
              validMasternodeListFullDF,
              pastelID,
              passphrase
            );

          return {
            creditPackRequest,
            creditPackPurchaseRequestConfirmation,
            creditPackStorageRetryRequestResponse,
          };
        } else {
          return {
            creditPackRequest,
            creditPackPurchaseRequestConfirmation,
            creditPackPurchaseRequestConfirmationResponse,
          };
        }
      } catch (error) {
        browserLogger.warn(
          `Failed to create credit pack with supernode ${supernode.url}: ${
            (error as Error).message
          }`
        );
      }
    }

    throw new Error(
      "Failed to create credit pack ticket with all available supernodes"
    );
  } catch (error) {
    browserLogger.error(
      `Error in handleCreditPackTicketEndToEnd: ${(error as Error).message}`
    );
    throw new Error(
      "An unexpected error occurred while processing your credit pack purchase. Please try again later."
    );
  }
}

async function buildCreditPackPurchaseRequestConfirmation(
  creditPackRequest: CreditPackPurchaseRequest,
  signedCreditPackTicket: CreditPackPurchaseRequestResponse,
  burnTransactionTxid: string,
  pastelID: string,
  passphrase: string
): Promise<CreditPackPurchaseRequestConfirmation> {
  const confirmation: CreditPackPurchaseRequestConfirmation = {
    sha3_256_hash_of_credit_pack_purchase_request_fields:
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
    sha3_256_hash_of_credit_pack_purchase_request_response_fields:
      signedCreditPackTicket.sha3_256_hash_of_credit_pack_purchase_request_response_fields,
    credit_pack_purchase_request_fields_json_b64:
      signedCreditPackTicket.credit_pack_purchase_request_fields_json_b64,
    requesting_end_user_pastelid: pastelID,
    txid_of_credit_purchase_burn_transaction: burnTransactionTxid,
    credit_purchase_request_confirmation_utc_iso_string:
      new Date().toISOString(),
    credit_purchase_request_confirmation_pastel_block_height:
      await rpc.getCurrentPastelBlockHeight(),
    credit_purchase_request_confirmation_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: "",
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields:
      "",
  };

  confirmation.sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields =
    await utils.computeSHA3256HashOfSQLModelResponseFields(confirmation);
  confirmation.requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields =
    await rpc.signMessageWithPastelID(
      pastelID,
      confirmation.sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields,
      passphrase
    );

  const { success, error } =
    schemas.creditPackPurchaseRequestConfirmationSchema.safeParse(confirmation);
  if (!success) {
    throw new Error(
      `Invalid credit pack purchase request confirmation: ${error.message}`
    );
  }

  return confirmation;
}

async function checkCreditPackPurchaseRequestStatus(
  inferenceClient: PastelInferenceClient,
  highestRankedSupernodeURL: string,
  creditPackRequest: CreditPackPurchaseRequest,
  closestSupernodes: SupernodeURL[]
): Promise<schemas.CreditPackPurchaseRequestStatus> {
  try {
    const status = await inferenceClient.checkStatusOfCreditPurchaseRequest(
      highestRankedSupernodeURL,
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields
    );
    browserLogger.info(
      `Credit pack purchase request status from the original supernode: ${JSON.stringify(
        status
      )}`
    );
    return status;
  } catch (error) {
    browserLogger.debug(
      `Error checking status with original supernode: ${
        (error as Error).message
      }. Trying other supernodes.`
    );
    for (const supernode of closestSupernodes) {
      try {
        const status = await inferenceClient.checkStatusOfCreditPurchaseRequest(
          supernode.url,
          creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields
        );
        browserLogger.info(
          `Credit pack purchase request status: ${JSON.stringify(status)}`
        );
        return status;
      } catch (retryError) {
        browserLogger.debug(
          `Error checking status with supernode ${supernode.url}: ${
            (retryError as Error).message
          }`
        );
      }
    }
    throw new Error(
      "Failed to check status of credit purchase request with all Supernodes"
    );
  }
}

async function initiateStorageRetry(
  inferenceClient: PastelInferenceClient,
  creditPackRequest: CreditPackPurchaseRequest,
  signedCreditPackTicket: CreditPackPurchaseRequestResponse,
  validMasternodeListFullDF: SupernodeInfo[],
  pastelID: string,
  passphrase: string
): Promise<CreditPackStorageRetryRequestResponse> {
  const closestAgreeingSupernodePastelID =
    await utils.getClosestSupernodePastelIDFromList(
      pastelID,
      JSON.parse(
        signedCreditPackTicket.list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms
      )
    );

  if (closestAgreeingSupernodePastelID === null) {
    throw new Error("No agreeing Supernode found for credit pack storage retry");
  }

  const creditPackStorageRetryRequest =
    await buildCreditPackStorageRetryRequest(
      creditPackRequest,
      signedCreditPackTicket,
      closestAgreeingSupernodePastelID,
      pastelID,
      passphrase
    );

  await db.addData(
    "CreditPackStorageRetryRequest",
    creditPackStorageRetryRequest
  );

  const closestAgreeingSupernodeURL = await utils.getSupernodeUrlFromPastelID(
    closestAgreeingSupernodePastelID,
    validMasternodeListFullDF
  );

  const creditPackStorageRetryRequestResponse =
    await inferenceClient.creditPackStorageRetryRequest(
      closestAgreeingSupernodeURL,
      creditPackStorageRetryRequest
    );

  const { success, error } =
    schemas.creditPackStorageRetryRequestResponseSchema.safeParse(
      creditPackStorageRetryRequestResponse
    );

  if (!success) {
    throw new Error(
      `Invalid credit pack storage retry request response: ${error.message}`
    );
  }

  // Silently attempt to announce completion to all agreeing supernodes
  const announcementPromises = JSON.parse(
    signedCreditPackTicket.list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms
  ).map(async (supernodePastelID: string) => {
    if (utils.checkIfPastelIDIsValid(supernodePastelID)) {
      try {
        const supernodeURL = await utils.getSupernodeUrlFromPastelID(
          supernodePastelID,
          validMasternodeListFullDF
        );
await inferenceClient.creditPackPurchaseCompletionAnnouncement(
  supernodeURL,
  creditPackStorageRetryRequestResponse as unknown as CreditPackPurchaseRequestConfirmation
);
      } catch {
        // Silently ignore errors in completion announcements
      }
    }
  });

  await Promise.allSettled(announcementPromises);

  return creditPackStorageRetryRequestResponse;
}

async function buildCreditPackStorageRetryRequest(
  creditPackRequest: CreditPackPurchaseRequest,
  signedCreditPackTicket: CreditPackPurchaseRequestResponse,
  closestAgreeingSupernodePastelID: string,
  pastelID: string,
  passphrase: string
): Promise<CreditPackStorageRetryRequest> {
  const storageRetryRequest: CreditPackStorageRetryRequest = {
    sha3_256_hash_of_credit_pack_purchase_request_response_fields:
      signedCreditPackTicket.sha3_256_hash_of_credit_pack_purchase_request_response_fields,
    credit_pack_purchase_request_fields_json_b64:
      signedCreditPackTicket.credit_pack_purchase_request_fields_json_b64,
    requesting_end_user_pastelid: pastelID,
    closest_agreeing_supernode_to_retry_storage_pastelid:
      closestAgreeingSupernodePastelID,
    credit_pack_storage_retry_request_timestamp_utc_iso_string:
      new Date().toISOString(),
    credit_pack_storage_retry_request_pastel_block_height:
      await rpc.getCurrentPastelBlockHeight(),
    credit_pack_storage_retry_request_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_storage_retry_request_fields: "",
    requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash:
      "",
  };

  storageRetryRequest.sha3_256_hash_of_credit_pack_storage_retry_request_fields =
    await utils.computeSHA3256HashOfSQLModelResponseFields(storageRetryRequest);
  storageRetryRequest.requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash =
    await rpc.signMessageWithPastelID(
      pastelID,
      storageRetryRequest.sha3_256_hash_of_credit_pack_storage_retry_request_fields,
      passphrase
    );

  const { success, error } =
    schemas.creditPackStorageRetryRequestSchema.safeParse(storageRetryRequest);
  if (!success) {
    throw new Error(
      `Invalid credit pack storage retry request: ${error.message}`
    );
  }

  return storageRetryRequest;
}

export async function getCreditPackTicketInfoEndToEnd(
  creditPackTicketPastelTxid: string,
  optionalPastelID?: string,
  optionalPassphrase?: string
): Promise<CreditPackTicketInfo> {
  try {
    browserLogger.info("getCreditPackTicketInfoEndToEnd called with:", {
      creditPackTicketPastelTxid,
      optionalPastelID: optionalPastelID ? "[PROVIDED]" : "[NOT PROVIDED]",
      optionalPassphrase: optionalPassphrase ? "[PROVIDED]" : "[NOT PROVIDED]",
    });
    let pastelID: string, passphrase: string;

    if (optionalPastelID && optionalPassphrase) {
      pastelID = optionalPastelID;
      passphrase = optionalPassphrase;
    } else {
      pastelID = pastelGlobals.getPastelId() || "";
      passphrase = pastelGlobals.getPassphrase() || "";
    }
    browserLogger.info("Using PastelID:", pastelID);

    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient({ pastelID, passphrase });
    const { validMasternodeListFullDF } = await rpc.checkSupernodeList();
    const { url: supernodeURL } = await utils.getClosestSupernodeToPastelIDURL(
      pastelID,
      validMasternodeListFullDF
    );
    if (!supernodeURL) {
      throw new Error("Supernode URL is undefined");
    }
    browserLogger.info(
      `Getting credit pack ticket data from Supernode URL: ${supernodeURL}...`
    );

    const { requestResponse, requestConfirmation } =
      await inferenceClient.getCreditPackTicketFromTxid(
        supernodeURL,
        creditPackTicketPastelTxid
      );

    const balanceInfo = await inferenceClient.checkCreditPackBalance(
      supernodeURL,
      creditPackTicketPastelTxid
    );

    return {
      requestResponse,
      requestConfirmation,
      balanceInfo: {
        credit_pack_current_credit_balance: Number(balanceInfo.credit_pack_current_credit_balance),
        balance_as_of_datetime: String(balanceInfo.balance_as_of_datetime),
      },
    };
  } catch (error) {
    browserLogger.error(
      `Error in getCreditPackTicketInfoEndToEnd: ${(error as Error).message}`
    );
    throw error;
  }
}

export async function getMyValidCreditPackTicketsEndToEnd(): Promise<
  CreditPack[]
> {
  const initialMinimumNonEmptyResponses = 5;
  const maxTotalResponsesIfAllEmpty = 20;
  const retryLimit = 1;

  try {
    const pastelID = pastelGlobals.getPastelId();
    const passphrase = pastelGlobals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }

    const inferenceClient = new PastelInferenceClient({ pastelID, passphrase });
    const { validMasternodeListFullDF } = await rpc.checkSupernodeList();

    const closestSupernodes = await utils.getNClosestSupernodesToPastelIDURLs(
      120,
      pastelID,
      validMasternodeListFullDF
    );

    const allResponses: { response: CreditPack[]; url: string }[] = [];
    const nonEmptyResponses: { response: CreditPack[]; url: string }[] = [];
    let isResolved = false;

    await new Promise<void>((resolve) => {
      let completedRequests = 0;

      const handleResponse = () => {
        if (isResolved) return;

        if (nonEmptyResponses.length >= initialMinimumNonEmptyResponses) {
          browserLogger.info(
            `Received ${nonEmptyResponses.length} non-empty responses out of ${allResponses.length} total responses`
          );
          isResolved = true;
          resolve();
        } else if (allResponses.length >= maxTotalResponsesIfAllEmpty) {
          browserLogger.info(
            `Reached maximum total responses (${maxTotalResponsesIfAllEmpty}) with ${nonEmptyResponses.length} non-empty responses`
          );
          isResolved = true;
          resolve();
        } else if (completedRequests >= closestSupernodes.length) {
          browserLogger.warn(
            `Queried all available supernodes. Got ${nonEmptyResponses.length} non-empty responses out of ${allResponses.length} total responses`
          );
          isResolved = true;
          resolve();
        }
      };

      closestSupernodes.forEach(({ url }) => {
        if (isResolved) return;

        utils
          .retryPromise(
            () => inferenceClient.getValidCreditPackTicketsForPastelID(url),
            retryLimit
          )
          .then((response) => {
            if (isResolved) return;

            browserLogger.info(
              `Response received from supernode at ${url}; response length: ${response.length}`
            );
            allResponses.push({ response: response as unknown as CreditPack[], url });
            if (response.length > 0) {
              nonEmptyResponses.push({ response: response as unknown as CreditPack[], url });
            }
            completedRequests++;
            handleResponse();
          })
          .catch((error) => {
            if (isResolved) return;

            browserLogger.error(
              `Error querying supernode at ${url}: ${(error as Error).message}`
            );
            completedRequests++;
            handleResponse();
          });
      });
    });

    if (nonEmptyResponses.length > 0) {
      // Return the longest non-empty response
      const longestResponse = nonEmptyResponses.reduce((prev, current) => {
        return current.response.length > prev.response.length ? current : prev;
      }).response;
      browserLogger.info(
        `Returning longest non-empty response with length: ${longestResponse.length}`
      );
      return longestResponse;
    } else {
      browserLogger.info("All responses were empty. Returning empty list.");
      return [];
    }
  } catch (error) {
    browserLogger.error(
      `Error in getMyValidCreditPackTicketsEndToEnd: ${
        (error as Error).message
      }`
    );
    return [];
  }
}

export async function estimateCreditPackCostEndToEnd(
  desiredNumberOfCredits: number,
  creditPriceCushionPercentage: number
): Promise<number> {
  try {
    const pastelID = pastelGlobals.getPastelId();
    const passphrase = pastelGlobals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient({ pastelID, passphrase });
    const estimatedTotalCostOfTicket =
      await inferenceClient.internalEstimateOfCreditPackTicketCostInPSL(
        desiredNumberOfCredits,
        creditPriceCushionPercentage
      );
    return estimatedTotalCostOfTicket;
  } catch (error) {
    browserLogger.error(
      `Error in estimateCreditPackCostEndToEnd: ${(error as Error).message}`
    );
    throw error;
  }
}

export async function handleInferenceRequestEndToEnd(
  params: InferenceRequestParams
): Promise<InferenceResult | null> {
  try {
    const pastelID = pastelGlobals.getPastelId();
    const passphrase = pastelGlobals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient({ pastelID, passphrase });
    const modelParametersJSON = utils.safeStringify(params.modelParameters);

    const supernodeURLs =
      await inferenceClient.getClosestSupernodeURLsThatSupportsDesiredModel(
        params.requestedModelCanonicalString,
        params.modelInferenceTypeString,
        modelParametersJSON,
        12
      );

    if (!supernodeURLs || supernodeURLs.length === 0) {
      console.error(
        `No supporting supernode found with adequate performance for the desired model: ${params.requestedModelCanonicalString} with inference type: ${params.modelInferenceTypeString}`
      );
      return null;
    }

    const maxTries = Math.min(5, supernodeURLs.length);

    for (let i = 0; i < maxTries; i++) {
      const supernodeURL = supernodeURLs[i];
      console.log(
        `Attempting inference request to Supernode URL: ${supernodeURL}`
      );

      try {
        const modelInputDataJSONBase64Encoded = btoa(
          JSON.stringify(params.modelInputData)
        );
        const modelParametersJSONBase64Encoded = btoa(modelParametersJSON);
        const currentBlockHeight = await rpc.getCurrentPastelBlockHeight();

        const inferenceRequestData: InferenceAPIUsageRequest = {
          inference_request_id: utils.generateUUID(),
          requesting_pastelid: pastelID,
          credit_pack_ticket_pastel_txid: params.creditPackTicketPastelTxid,
          requested_model_canonical_string: params.requestedModelCanonicalString,
          model_inference_type_string: params.modelInferenceTypeString,
          model_parameters_json_b64: modelParametersJSONBase64Encoded,
          model_input_data_json_b64: modelInputDataJSONBase64Encoded,
          inference_request_utc_iso_string: new Date().toISOString(),
          inference_request_pastel_block_height: currentBlockHeight,
          status: "initiating",
          inference_request_message_version_string: "1.0",
          sha3_256_hash_of_inference_request_fields: "",
          requesting_pastelid_signature_on_request_hash: "",
        };

        inferenceRequestData.sha3_256_hash_of_inference_request_fields =
          await utils.computeSHA3256HashOfSQLModelResponseFields(
            inferenceRequestData
          );
        inferenceRequestData.requesting_pastelid_signature_on_request_hash =
          await rpc.signMessageWithPastelID(
            pastelID,
            inferenceRequestData.sha3_256_hash_of_inference_request_fields,
            passphrase
          );

        const usageRequestResponse =
          await inferenceClient.makeInferenceAPIUsageRequest(
            supernodeURL,
            inferenceRequestData
          );

        const validationErrors =
          await utils.validateCreditPackTicketMessageData(usageRequestResponse);
        if (validationErrors && validationErrors.length > 0) {
          throw new Error(
            `Invalid inference request response from Supernode URL ${supernodeURL}: ${validationErrors.join(
              ", "
            )}`
          );
        }

        const inferenceRequestID = usageRequestResponse.inference_request_id;
        const inferenceResponseID = usageRequestResponse.inference_response_id;
        const proposedCostInCredits = parseFloat(
          usageRequestResponse.proposed_cost_of_request_in_inference_credits.toString()
        );
        const creditUsageTrackingPSLAddress =
          usageRequestResponse.credit_usage_tracking_psl_address;
        const creditUsageTrackingAmountInPSL =
          parseFloat(
            usageRequestResponse.request_confirmation_message_amount_in_patoshis.toString()
          ) / 100000;
        
        const trackingAddressBalance = await rpc.checkPSLAddressBalance(
          creditUsageTrackingPSLAddress
        );

        if (trackingAddressBalance < creditUsageTrackingAmountInPSL) {
          console.error(
            `Insufficient balance in tracking address: ${creditUsageTrackingPSLAddress}; amount needed: ${creditUsageTrackingAmountInPSL}; current balance: ${trackingAddressBalance}; shortfall: ${
              creditUsageTrackingAmountInPSL - trackingAddressBalance
            }`
          );
          return null;
        }

        if (proposedCostInCredits <= params.maximumInferenceCostInCredits) {
          const burnAddress = await rpc.getBurnAddress();
          const trackingTransactionTxid =
            await rpc.sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest(
              inferenceRequestID,
              creditUsageTrackingPSLAddress,
              creditUsageTrackingAmountInPSL,
              burnAddress
            );

          const txidLooksValid = /^[0-9a-fA-F]{64}$/.test(
            trackingTransactionTxid
          );

          if (txidLooksValid) {
            const confirmationData: InferenceConfirmation = {
              inference_request_id: inferenceRequestID,
              requesting_pastelid: pastelID,
              confirmation_transaction: { txid: trackingTransactionTxid },
            };

            const confirmationResult =
              await inferenceClient.sendInferenceConfirmation(
                supernodeURL,
                confirmationData
              );

            console.log(
              `Sent inference confirmation: ${utils.prettyJSON(
                confirmationResult
              )}`
            );

            const maxTriesToGetConfirmation = 60;
            const initialWaitTimeInSeconds = 3;
            let waitTimeInSeconds = initialWaitTimeInSeconds;

            for (let cnt = 0; cnt < maxTriesToGetConfirmation; cnt++) {
              waitTimeInSeconds = waitTimeInSeconds * 1.04 ** cnt;
              console.log(
                `Waiting for the inference results for ${Math.round(
                  waitTimeInSeconds
                )} seconds... (Attempt ${
                  cnt + 1
                }/${maxTriesToGetConfirmation}); Checking with Supernode URL: ${supernodeURL}`
              );

              await new Promise((resolve) =>
                setTimeout(resolve, waitTimeInSeconds * 1000)
              );

              if (
                inferenceRequestID.length === 0 ||
                inferenceResponseID.length === 0
              ) {
                throw new Error("Inference request ID or response ID is empty");
              }

              const resultsAvailable =
                await inferenceClient.checkStatusOfInferenceRequestResults(
                  supernodeURL,
                  inferenceResponseID
                );

              if (resultsAvailable) {
                const outputResults =
                  await inferenceClient.retrieveInferenceOutputResults(
                    supernodeURL,
                    inferenceRequestID,
                    inferenceResponseID
                  );

                const inferenceResult: InferenceResult = {
                  supernode_url: supernodeURL,
                  request_data: inferenceRequestData,
                  usage_request_response: usageRequestResponse,
                  model_input_data_json: params.modelInputData,
                  output_results: outputResults,
                };

                if (params.modelInferenceTypeString === "text_to_image") {
                  const jsonString = atob(
                    outputResults.inference_result_json_base64
                  );
                  const jsonObject = JSON.parse(jsonString);
                  const imageBase64 = jsonObject.image;
                  inferenceResult.generated_image_decoded = atob(imageBase64);
                } else if (
                  params.modelInferenceTypeString === "embedding_document"
                ) {
                  const inferenceResultDecoded = atob(
                    outputResults.inference_result_json_base64
                  );
                  const zipBinary = atob(inferenceResultDecoded);
                  inferenceResult.zip_file_data = zipBinary;
                } else {
                  const inferenceResultDecoded = atob(
                    outputResults.inference_result_json_base64
                  );
                  console.log(`Decoded response:\n${inferenceResultDecoded}`);
                  inferenceResult.inference_result_decoded = inferenceResultDecoded;
                }

                const useAuditFeature = false;

                if (useAuditFeature) {
                  console.log(
                    "Waiting 3 seconds for audit results to be available..."
                  );
                  await new Promise((resolve) => setTimeout(resolve, 3000));

                  const auditResults =
                    await inferenceClient.auditInferenceRequestResponseID(
                      inferenceResponseID
                    );
                  const validationResults = utils.validateInferenceData(
                    inferenceResult,
                    auditResults
                  );
                  console.log(
                    `Validation results: ${utils.prettyJSON(validationResults)}`
                  );
                  if (!auditResults) {
                    console.warn("Audit results are null");
                  }
                  if (!validationResults) {
                    console.warn("Validation results are null");
                  }
                }

                return inferenceResult;
              } else {
                console.log("Inference results not available yet; retrying...");
              }
            }
          }
        } else {
          console.log(
            `Quoted price of ${proposedCostInCredits} credits exceeds the maximum allowed cost of ${params.maximumInferenceCostInCredits} credits. Inference request not confirmed.`
          );
        }
      } catch (err) {
        console.warn(
          `Failed inference request to Supernode URL ${supernodeURL}. Moving on to the next one. Error: ${(err as Error).message}`
        );
      }
    }

    console.error(
      `Failed to make inference request after ${maxTries} tries.`
    );
    return null;
  } catch (error) {
    console.error(
      `Error in handleInferenceRequestEndToEnd: ${(error as Error).message}`
    );
    throw error;
  }
}

---
./src/app/lib/logger.ts
---
// src/app/lib/logger.ts

'use client'

import { BrowserLogger, LogEntry, LoggerListener } from '@/app/types';

class BrowserLoggerImpl implements BrowserLogger {
  logBuffer: string[] = [];
  MAX_LOG_ENTRIES: number = 1000;
  listeners: Map<string, Set<LoggerListener>> = new Map();

  log(level: string, msg: string, meta?: unknown): void {
    const logEntry: LogEntry = { level, msg, meta, timestamp: new Date().toISOString() };
    this.logBuffer.push(this.safeStringify(logEntry));
    if (this.logBuffer.length > this.MAX_LOG_ENTRIES) {
      this.logBuffer.shift();
    }
    this.emit('newLog', this.safeStringify(logEntry));

    switch (level) {
      case 'error':
        console.error(msg, meta);
        break;
      case 'warn':
        console.warn(msg, meta);
        break;
      case 'info':
        console.info(msg, meta);
        break;
      default:
        console.log(msg, meta);
    }
  }

  error(msg: string, meta?: unknown): void {
    this.log('error', msg, meta);
  }

  warn(msg: string, meta?: unknown): void {
    this.log('warn', msg, meta);
  }

  info(msg: string, meta?: unknown): void {
    this.log('info', msg, meta);
  }

  debug(msg: string, meta?: unknown): void {
    this.log('debug', msg, meta);
  }

  on(eventName: string, listener: LoggerListener): void {
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, new Set());
    }
    this.listeners.get(eventName)!.add(listener);
  }

  off(eventName: string, listener: LoggerListener): void {
    if (this.listeners.has(eventName)) {
      this.listeners.get(eventName)!.delete(listener);
    }
  }

  emit(eventName: string, data: string): void {
    if (this.listeners.has(eventName)) {
      this.listeners.get(eventName)!.forEach((listener) => {
        listener(data);
      });
    }
  }

  safeStringify(obj: unknown): string {
    return JSON.stringify(obj, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    );
  }
}

const browserLogger = new BrowserLoggerImpl();
export default browserLogger;

---
./src/app/lib/BrowserRPCReplacement.ts
---
// src/app/lib/BrowserRPCReplacement.ts

'use client'

import {
  SupernodeInfo,
  WalletInfo,
  PastelIDTicket,
  NetworkMode,
  TransactionDetail,
  BlockInfo,
  MempoolInfo,
  BlockchainInfo,
  TxOutSetInfo,
  ChainTip,
  BlockHeader,
  TxOutInfo,
  MemoryInfo,
  BlockSubsidy,
  BlockTemplate,
  MiningInfo,
  NetworkSolPs,
  NodeInfo,
  PeerInfo,
  DecodedRawTransaction,
  DecodedScript,
  ValidatedAddress,
  PastelIDInfo,
} from "@/app/types";
import {
  getNetworkFromLocalStorage,
  setNetworkInLocalStorage,
} from "@/app/lib/storage";

declare global {
  interface Window {
    Module: {
      Pastel: new () => PastelInstance;
    };
  }
}

interface PastelInstance {
  VerifyWithPastelID: (
    pastelid: string,
    messageToVerify: string,
    pastelIDSignatureOnMessage: string,
    network: string
  ) => string;
  SignWithPastelID: (
    pastelid: string,
    messageToSign: string,
    type: string,
    network: string
  ) => string;
  CreateNewWallet: (password: string) => string;
  ImportWallet: (serializedWallet: string) => string;
  ExportWallet: () => string;
  MakeNewAddress: (networkMode: NetworkMode) => string;
  GetAddress: (index: number, networkMode: NetworkMode) => string;
  GetAddressesCount: () => number;
  MakeNewPastelID: (makeFullPair: boolean) => string;
  GetPastelIDByIndex: (index: number, type: string) => string;
  GetPastelIDsCount: () => number;
  CreateSendToTransaction: (
    networkMode: NetworkMode,
    sendToJson: string,
    fromAddress: string,
    utxosJson: string,
    blockHeight: number,
    fee: number
  ) => string;
  CreateRegisterPastelIdTransaction: (
    networkMode: NetworkMode,
    pastelID: string,
    fundingAddress: string,
    utxosJson: string,
    blockHeight: number,
    fee: number
  ) => string;
  SignWithWalletKey: (message: string) => string;
  UnlockWallet: (password: string) => string;
  LockWallet: () => string;
  GetWalletPubKey: () => string;
  DumpPrivKey: (tAddr: string) => string;
  ImportPrivKey: (privKey: string, label: string, rescan: boolean) => string;
  RegisterPastelID: (
    pastelid: string,
    passphrase: string,
    address: string
  ) => string;
  CreateWalletFromMnemonic: (password: string, mnemonic: string) => string;
}

class BrowserRPCReplacement {
  private apiBaseUrl: string;
  private pastelInstance: PastelInstance | null;
  private isInitialized: boolean;

  constructor(apiBaseUrl: string = "https://opennode-fastapi.pastel.network") {
    this.apiBaseUrl = apiBaseUrl;
    this.pastelInstance = null;
    this.isInitialized = false;
  }

  async initialize(): Promise<void> {
    if (!this.isInitialized) {
      if (
        typeof window === "undefined" ||
        !window.Module ||
        !window.Module.Pastel
      ) {
        throw new Error("WASM module not loaded");
      }
      this.pastelInstance = new window.Module.Pastel();
      this.isInitialized = true;
    }
  }

  async ensureInitialized(): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }
  }

  private getNetworkMode(mode: string): NetworkMode {
    const modeMap: { [key: string]: NetworkMode } = {
      Mainnet: NetworkMode.Mainnet,
      Testnet: NetworkMode.Testnet,
      Devnet: NetworkMode.Devnet,
    };
    return modeMap[mode] || NetworkMode.Mainnet;
  }

  private executeWasmMethod<T>(method: () => string | number): T {
    if (!this.pastelInstance) {
      throw new Error("Pastel instance not initialized");
    }
    try {
      const result = method();
      if (typeof result === 'number') {
        return result as T;
      }
      return this.parseWasmResponse<T>(result);
    } catch (error) {
      console.error("WASM method execution failed:", error);
      throw new Error(
        `WASM method execution failed: ${(error as Error).message}`
      );
    }
  }

  private parseWasmResponse<T>(response: string): T {
    try {
      const parsedResponse = JSON.parse(response);
      if (parsedResponse.result) {
        return parsedResponse.data as T;
      } else {
        throw new Error(
          parsedResponse.error || "Unknown error in WASM response"
        );
      }
    } catch (error) {
      console.error("Error parsing WASM response:", error);
      throw new Error(
        `Error parsing WASM response: ${(error as Error).message}`
      );
    }
  }

  private async fetchJson<T>(endpoint: string): Promise<T> {
    try {
      const response = await fetch(this.apiBaseUrl + endpoint);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return (await response.json()) as T;
    } catch (error) {
      console.error(`Error fetching from ${endpoint}:`, error);
      throw error;
    }
  }

  async checkMasternodeTop(): Promise<SupernodeInfo[]> {
    return this.fetchJson<SupernodeInfo[]>("/masternode/top");
  }

  async getCurrentPastelBlockHeight(): Promise<number> {
    return this.fetchJson<number>("/getblockcount");
  }

  async getBestBlockHashAndMerkleRoot(): Promise<[string, string, number]> {
    const blockHeight = await this.getCurrentPastelBlockHeight();
    const blockHash = await this.getBlockHash(blockHeight);
    const block = await this.getBlock(blockHash);
    return [blockHash, block.merkleroot, blockHeight];
  }

  async verifyMessageWithPastelID(
    pastelid: string,
    messageToVerify: string,
    pastelIDSignatureOnMessage: string
  ): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.VerifyWithPastelID(
        pastelid,
        messageToVerify,
        pastelIDSignatureOnMessage,
        "Mainnet"
      )
    );
  }

  async sendToAddress(address: string, amount: number): Promise<string> {
    await this.ensureInitialized();
    const sendTo = [{ address, amount }];
    const fromAddress = await this.getMyPslAddressWithLargestBalance();
    return this.createSendToTransaction(sendTo, fromAddress);
  }

  async sendMany(
    amounts: { address: string; amount: number }[]
  ): Promise<string> {
    await this.ensureInitialized();
    const fromAddress = await this.getMyPslAddressWithLargestBalance();
    return this.createSendToTransaction(amounts, fromAddress);
  }

  async checkPSLAddressBalance(addressToCheck: string): Promise<number> {
    return this.fetchJson<number>(
      `/get_address_balance?addresses=${addressToCheck}`
    );
  }

  async checkIfAddressIsAlreadyImportedInLocalWallet(
    addressToCheck: string
  ): Promise<boolean> {
    await this.ensureInitialized();
    const addresses = await this.getAllAddresses();
    return addresses.includes(addressToCheck);
  }

  async getAndDecodeRawTransaction(
    txid: string
  ): Promise<DecodedRawTransaction> {
    const rawTx = await this.fetchJson<string>(`/getrawtransaction/${txid}`);
    return this.fetchJson<DecodedRawTransaction>(
      `/decoderawtransaction/${rawTx}`
    );
  }

  async getTransactionDetails(
    txid: string,
    includeWatchonly: boolean = false
  ): Promise<TransactionDetail> {
    return this.fetchJson<TransactionDetail>(
      `/gettransaction/${txid}?includeWatchonly=${includeWatchonly}`
    );
  }

  async sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest(
    inferenceRequestId: string,
    creditUsageTrackingPSLAddress: string,
    creditUsageTrackingAmountInPSL: number,
    burnAddress: string
  ): Promise<string> {
    const sendTo = [
      { address: burnAddress, amount: creditUsageTrackingAmountInPSL },
    ];
    return this.createSendToTransaction(sendTo, creditUsageTrackingPSLAddress);
  }

  async importAddress(address: string): Promise<void> {
    await this.ensureInitialized();
    const importedAddresses = JSON.parse(
      localStorage.getItem("importedAddresses") || "[]"
    ) as string[];
    if (!importedAddresses.includes(address)) {
      importedAddresses.push(address);
      localStorage.setItem(
        "importedAddresses",
        JSON.stringify(importedAddresses)
      );
    }
    console.log(`Address ${address} has been tracked for monitoring.`);
  }

  async getBlockHash(blockHeight: number): Promise<string> {
    return this.fetchJson<string>(`/getblockhash/${blockHeight}`);
  }

  async getBlock(blockHash: string): Promise<BlockInfo> {
    return this.fetchJson<BlockInfo>(`/getblock/${blockHash}`);
  }

async signMessageWithPastelID(
    pastelid: string,
    messageToSign: string,
    passphrase: string
  ): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.SignWithPastelID(
        pastelid,
        messageToSign,
        passphrase,
        "Mainnet"
      )
    );
  }
  async createAndFundNewPSLCreditTrackingAddress(
    amountOfPSLToFundAddressWith: number
  ): Promise<{ newCreditTrackingAddress: string; txid: string }> {
    await this.ensureInitialized();
    const newAddress = await this.makeNewAddress();
    const txid = await this.sendToAddress(
      newAddress,
      amountOfPSLToFundAddressWith
    );
    return { newCreditTrackingAddress: newAddress, txid };
  }

  async checkSupernodeList(): Promise<{
    validMasternodeListFullDF: SupernodeInfo[];
  }> {
    return this.fetchJson<{ validMasternodeListFullDF: SupernodeInfo[] }>(
      "/supernode_data"
    );
  }

  async createAndRegisterNewPastelID(): Promise<{
    success: boolean;
    PastelID: string;
    PastelIDRegistrationTXID: string;
  }> {
    await this.ensureInitialized();
    const pastelID = await this.makeNewPastelID(true);
    const fundingAddress = await this.getMyPslAddressWithLargestBalance();
    const txid = await this.createRegisterPastelIdTransaction(
      pastelID,
      fundingAddress
    );
    return {
      success: true,
      PastelID: pastelID,
      PastelIDRegistrationTXID: txid,
    };
  }

  async getBalance(): Promise<number> {
    await this.ensureInitialized();
    const addresses = await this.getAllAddresses();
    let totalBalance = 0;
    for (const address of addresses) {
      const balance = await this.checkPSLAddressBalance(address);
      totalBalance += balance;
    }
    return totalBalance;
  }

  async getWalletInfo(): Promise<WalletInfo> {
    await this.ensureInitialized();
    const balance = await this.getBalance();
    return {
      walletversion: 1,
      balance,
      unconfirmed_balance: 0,
      immature_balance: 0,
      txcount: await this.getWalletTransactionCount(),
      keypoololdest: 0,
      keypoolsize: 0,
      paytxfee: 0.001,
      seedfp: "Not available",
    };
  }

  async getNewAddress(): Promise<string> {
    await this.ensureInitialized();
    return this.makeNewAddress();
  }

  async getMyPslAddressWithLargestBalance(): Promise<string> {
    await this.ensureInitialized();
    const addresses = await this.getAllAddresses();
    let maxBalance = -1;
    let addressWithMaxBalance = "";
    for (const address of addresses) {
      const balance = await this.checkPSLAddressBalance(address);
      if (balance > maxBalance) {
        maxBalance = balance;
        addressWithMaxBalance = address;
      }
    }
    return addressWithMaxBalance;
  }

  async getAllAddresses(mode: string = "Mainnet"): Promise<string[]> {
    await this.ensureInitialized();
    const addressCount = await this.getAddressesCount();
    const addresses: string[] = [];
    for (let i = 0; i < addressCount; i++) {
      addresses.push(await this.getAddress(i, mode));
    }
    return addresses;
  }

  async getWalletTransactionCount(): Promise<number> {
    const transactions = JSON.parse(
      localStorage.getItem("transactions") || "[]"
    ) as unknown[];
    return transactions.length;
  }

  async createNewWallet(password: string): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.CreateNewWallet(password)
    );
  }

  async importWallet(serializedWallet: string): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.ImportWallet(serializedWallet)
    );
  }

  async exportWallet(): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.ExportWallet()
    );
  }

  async makeNewAddress(mode: string = "Mainnet"): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.MakeNewAddress(this.getNetworkMode(mode))
    );
  }

  async getAddress(index: number, mode: string = "Mainnet"): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.GetAddress(index, this.getNetworkMode(mode))
    );
  }

  async getAddressesCount(): Promise<number> {
    await this.ensureInitialized();
    return this.executeWasmMethod<number>(() =>
      this.pastelInstance!.GetAddressesCount()
    );
  }

  async makeNewPastelID(makeFullPair: boolean = false): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.MakeNewPastelID(makeFullPair)
    );
  }
  async getPastelIDByIndex(
    index: number,
    type: string = "PastelID"
  ): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.GetPastelIDByIndex(index, type)
    );
  }

  async getPastelIDsCount(): Promise<number> {
    await this.ensureInitialized();
    return this.executeWasmMethod<number>(() =>
      this.pastelInstance!.GetPastelIDsCount()
    );
  }

  async createSendToTransaction(
    sendTo: { address: string; amount: number }[],
    fromAddress: string,
    mode: string = "Mainnet"
  ): Promise<string> {
    await this.ensureInitialized();
    const utxos = await this.getAddressUtxos(fromAddress);
    const blockHeight = await this.getCurrentPastelBlockHeight();
    const networkMode = this.getNetworkMode(mode);
    const sendToJson = JSON.stringify(sendTo);
    const utxosJson = JSON.stringify(utxos);

    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.CreateSendToTransaction(
        networkMode,
        sendToJson,
        fromAddress,
        utxosJson,
        blockHeight,
        0
      )
    );
  }

  async createRegisterPastelIdTransaction(
    pastelID: string,
    fundingAddress: string,
    mode: string = "Mainnet"
  ): Promise<string> {
    await this.ensureInitialized();
    const utxos = await this.getAddressUtxos(fundingAddress);
    const blockHeight = await this.getCurrentPastelBlockHeight();
    const networkMode = this.getNetworkMode(mode);
    const utxosJson = JSON.stringify(utxos);

    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.CreateRegisterPastelIdTransaction(
        networkMode,
        pastelID,
        fundingAddress,
        utxosJson,
        blockHeight,
        0
      )
    );
  }

  async signWithWalletKey(message: string): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.SignWithWalletKey(message)
    );
  }

  async unlockWallet(password: string): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.UnlockWallet(password)
    );
  }

  async lockWallet(): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.LockWallet()
    );
  }

  async getWalletPubKey(): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.GetWalletPubKey()
    );
  }

  async getAddressUtxos(address: string): Promise<unknown[]> {
    return this.fetchJson<unknown[]>(`/get_address_utxos?addresses=${address}`);
  }

  async listPastelIDTickets(
    filter: string = "mine",
    minheight: number | null = null
  ): Promise<PastelIDTicket[]> {
    let endpoint = `/tickets/id/list/${filter}`;
    if (minheight !== null) {
      endpoint += `/${minheight}`;
    }
    return this.fetchJson<PastelIDTicket[]>(endpoint);
  }

  async findPastelIDTicket(key: string): Promise<PastelIDTicket> {
    return this.fetchJson<PastelIDTicket>(`/tickets/id/find/${key}`);
  }

  async getPastelTicket(
    txid: string,
    decodeProperties: boolean = true
  ): Promise<unknown> {
    return this.fetchJson<unknown>(
      `/tickets/get/${txid}?decode_properties=${decodeProperties}`
    );
  }

  async listContractTickets(
    ticketTypeIdentifier: string,
    startingBlockHeight: number = 0
  ): Promise<unknown[]> {
    return this.fetchJson<unknown[]>(
      `/tickets/contract/list/${ticketTypeIdentifier}/${startingBlockHeight}`
    );
  }

  async findContractTicket(key: string): Promise<unknown> {
    return this.fetchJson<unknown>(`/tickets/contract/find/${key}`);
  }

  async getContractTicket(
    txid: string,
    decodeProperties: boolean = true
  ): Promise<unknown> {
    return this.fetchJson<unknown>(
      `/tickets/contract/get/${txid}?decode_properties=${decodeProperties}`
    );
  }

  async isPastelIDRegistered(pastelID: string): Promise<boolean> {
    return this.fetchJson<boolean>(`/tickets/id/is_registered/${pastelID}`);
  }

  async dumpPrivKey(tAddr: string): Promise<string> {
    await this.ensureInitialized();
    console.warn(
      "dumpPrivKey called in browser context. This operation may expose sensitive information."
    );
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.DumpPrivKey(tAddr)
    );
  }

  async importPrivKey(
    privKey: string,
    label: string = "",
    rescan: boolean = true
  ): Promise<string> {
    await this.ensureInitialized();
    console.warn(
      "importPrivKey called in browser context. This operation may expose sensitive information."
    );
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.ImportPrivKey(privKey, label, rescan)
    );
  }

  async listAddressAmounts(
    includeEmpty: boolean = false
  ): Promise<{ [address: string]: number }> {
    await this.ensureInitialized();
    const addresses = await this.getAllAddresses();
    const result: { [address: string]: number } = {};
    for (const address of addresses) {
      const balance = await this.checkPSLAddressBalance(address);
      if (includeEmpty || balance > 0) {
        result[address] = balance;
      }
    }
    return result;
  }

  async checkForRegisteredPastelID(): Promise<string | null> {
    await this.ensureInitialized();
    const pastelIDs = await this.getAllPastelIDs();
    for (const pastelID of pastelIDs) {
      const isRegistered = await this.isPastelIDRegistered(pastelID);
      if (isRegistered) {
        return pastelID;
      }
    }
    return null;
  }

  async getAllPastelIDs(): Promise<string[]> {
    await this.ensureInitialized();
    const count = await this.getPastelIDsCount();
    const pastelIDs: string[] = [];
    for (let i = 0; i < count; i++) {
      pastelIDs.push(await this.getPastelIDByIndex(i));
    }
    return pastelIDs;
  }

  async createAndRegisterPastelID(): Promise<{
    pastelID: string;
    txid: string;
  }> {
    await this.ensureInitialized();
    const pastelID = await this.makeNewPastelID(true);
    const fundingAddress = await this.getMyPslAddressWithLargestBalance();
    const txid = await this.createRegisterPastelIdTransaction(
      pastelID,
      fundingAddress
    );
    return { pastelID, txid };
  }

  async isCreditPackConfirmed(txid: string): Promise<boolean> {
    const ticket = await this.getPastelTicket(txid);
    return (
      typeof ticket === "object" &&
      ticket !== null &&
      "height" in ticket &&
      (ticket as { height: number }).height > 0
    );
  }

  async ensureTrackingAddressesHaveMinimalPSLBalance(
    addressesList: string[] | null = null
  ): Promise<void> {
    await this.ensureInitialized();
    const addresses = addressesList || (await this.getAllAddresses());

    for (const address of addresses) {
      const balance = await this.checkPSLAddressBalance(address);
      if (balance < 1.0) {
        const amountNeeded = Math.round((1.0 - balance) * 10000) / 10000;
        if (amountNeeded > 0.0001) {
          await this.sendToAddress(address, amountNeeded);
        }
      }
    }
  }

  formatNumberWithCommas(number: number): string {
    return new Intl.NumberFormat("en-US").format(number);
  }

  async getAddressHistory(address: string): Promise<unknown> {
    return this.fetchJson<unknown>(`/get_address_history/${address}`);
  }

  async getBestBlockHash(): Promise<string> {
    return this.fetchJson<string>("/getbestblockhash");
  }

  async getMempoolInfo(): Promise<MempoolInfo> {
    return this.fetchJson<MempoolInfo>("/getmempoolinfo");
  }

  async getRawMempool(): Promise<string[]> {
    return this.fetchJson<string[]>("/getrawmempool");
  }

  async estimateFee(nblocks: number): Promise<number> {
    return this.fetchJson<number>(`/estimatefee/${nblocks}`);
  }

  async validateAddress(address: string): Promise<ValidatedAddress> {
    return this.fetchJson<ValidatedAddress>(`/validateaddress/${address}`);
  }

  async getBlockchainInfo(): Promise<BlockchainInfo> {
    return this.fetchJson<BlockchainInfo>("/getblockchaininfo");
  }

  async getTxOutSetInfo(): Promise<TxOutSetInfo> {
    return this.fetchJson<TxOutSetInfo>("/gettxoutsetinfo");
  }

  async getChainTips(): Promise<ChainTip[]> {
    return this.fetchJson<ChainTip[]>("/getchaintips");
  }

  async getDifficulty(): Promise<number> {
    return this.fetchJson<number>("/getdifficulty");
  }

  async getBlockHeader(blockhash: string): Promise<BlockHeader> {
    return this.fetchJson<BlockHeader>(`/getblockheader/${blockhash}`);
  }

  async getTxOut(
    txid: string,
    vout_value: number,
    includemempool: boolean = true
  ): Promise<TxOutInfo | null> {
    return this.fetchJson<TxOutInfo | null>(
      `/gettxout/${txid}/${vout_value}?includemempool=${includemempool}`
    );
  }

  async getTxOutProof(txid: string): Promise<string> {
    return this.fetchJson<string>(`/gettxoutproof/${txid}`);
  }

  async verifyTxOutProof(proof: string): Promise<string[]> {
    return this.fetchJson<string[]>(`/verifytxoutproof/${proof}`);
  }

  async getInfo(): Promise<unknown> {
    return this.fetchJson<unknown>("/getinfo");
  }

  async getMemoryInfo(): Promise<MemoryInfo> {
    return this.fetchJson<MemoryInfo>("/getmemoryinfo");
  }

  async getBlockSubsidy(height: number): Promise<BlockSubsidy> {
    return this.fetchJson<BlockSubsidy>(`/getblocksubsidy/${height}`);
  }

  async getBlockTemplate(): Promise<BlockTemplate> {
    return this.fetchJson<BlockTemplate>("/getblocktemplate");
  }

  async getMiningInfo(): Promise<MiningInfo> {
    return this.fetchJson<MiningInfo>("/getmininginfo");
  }

  async getNextBlockSubsidy(): Promise<BlockSubsidy> {
    return this.fetchJson<BlockSubsidy>("/getnextblocksubsidy");
  }

  async getNetworkSolPs(blocks: number, height: number): Promise<NetworkSolPs> {
    return this.fetchJson<NetworkSolPs>(`/getnetworksolps/${blocks}/${height}`);
  }

  async getAddedNodeInfo(): Promise<NodeInfo[]> {
    return this.fetchJson<NodeInfo[]>("/getaddednodeinfo");
  }

  async getPeerInfo(): Promise<PeerInfo[]> {
    return this.fetchJson<PeerInfo[]>("/getpeerinfo");
  }

  async decodeRawTransaction(
    hexstring: string
  ): Promise<DecodedRawTransaction> {
    return this.fetchJson<DecodedRawTransaction>(
      `/decoderawtransaction/${hexstring}`
    );
  }

  async decodeScript(hexstring: string): Promise<DecodedScript> {
    return this.fetchJson<DecodedScript>(`/decodescript/${hexstring}`);
  }

  async zValidateAddress(shieldedAddress: string): Promise<ValidatedAddress> {
    return this.fetchJson<ValidatedAddress>(
      `/z_validateaddress/${shieldedAddress}`
    );
  }

  async listPastelIDTicketsOld(
    filter: string = "mine",
    minheight: number | null = null
  ): Promise<PastelIDInfo[]> {
    let endpoint = `/list_pastelid_tickets/${filter}`;
    if (minheight !== null) {
      endpoint += `/${minheight}`;
    }
    return this.fetchJson<PastelIDInfo[]>(endpoint);
  }

  async findPastelIDTicketOld(key: string): Promise<PastelIDInfo> {
    return this.fetchJson<PastelIDInfo>(`/find_pastelid_ticket/${key}`);
  }

  async registerPastelID(
    pastelid: string,
    passphrase: string,
    address: string
  ): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.RegisterPastelID(pastelid, passphrase, address)
    );
  }

  async checkPSLAddressBalanceAlternative(
    addressToCheck: string
  ): Promise<number> {
    const addressAmounts = await this.listAddressAmounts();
    return addressAmounts[addressToCheck] || 0;
  }

  async createWalletFromMnemonic(
    password: string,
    mnemonic: string
  ): Promise<string> {
    await this.ensureInitialized();
    return this.executeWasmMethod<string>(() =>
      this.pastelInstance!.CreateWalletFromMnemonic(password, mnemonic)
    );
  }

  async loadWallet(
    serializedWallet: string,
    password: string
  ): Promise<boolean> {
    await this.ensureInitialized();
    await this.importWallet(serializedWallet);
    if (password) {
      await this.unlockWallet(password);
    }
    return true;
  }

  async downloadWallet(
    filename: string = "pastel_wallet.dat"
  ): Promise<boolean> {
    await this.ensureInitialized();
    const content = await this.exportWallet();
    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.style.display = "none";
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    return true;
  }

  async selectAndReadWalletFile(): Promise<string> {
    return new Promise((resolve) => {
      const input = document.createElement("input");
      input.type = "file";
      input.onchange = (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (file) {
          const reader = new FileReader();
          reader.readAsText(file, "UTF-8");
          reader.onload = (readerEvent) => {
            const content = readerEvent.target?.result as string;
            resolve(content);
          };
        }
      };
      input.click();
    });
  }

  private async waitForConfirmation<T, Args extends unknown[]>(
    checkFunction: (...args: Args) => Promise<T>,
    ...checkFunctionArgs: Args
  ): Promise<T | false> {
    const maxRetries = 30;
    const retryDelay = 10000; // 10 seconds

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = await checkFunction(...checkFunctionArgs);
        if (result) {
          return result;
        }
      } catch (error) {
        console.warn(
          `Error in attempt ${attempt}: ${(error as Error).message}`
        );
      }

      if (attempt < maxRetries) {
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
      }
    }

    return false;
  }

  async waitForPastelIDRegistration(pastelID: string): Promise<boolean> {
    return this.waitForConfirmation(
      this.isPastelIDRegistered.bind(this),
      pastelID
    ) as Promise<boolean>;
  }

  async waitForCreditPackConfirmation(txid: string): Promise<boolean> {
    return this.waitForConfirmation(
      this.isCreditPackConfirmed.bind(this),
      txid
    ) as Promise<boolean>;
  }

  async importPromotionalPack(
    packData: string
  ): Promise<{ success: boolean; message: string; details?: unknown }> {
    try {
      await this.initialize();

      const pack = JSON.parse(packData);
      const { rpcport } = await this.getLocalRPCSettings();
      const network =
        rpcport === "9932"
          ? "mainnet"
          : rpcport === "19932"
          ? "testnet"
          : "devnet";

      // Store the secure container
      await this.storeSecureContainer(
        pack.pastel_id_pubkey,
        pack.secureContainerBase64,
        network
      );

      // Import the tracking address private key
      const importResult = await this.importPrivKey(
        pack.psl_credit_usage_tracking_address_private_key,
        "Imported from promotional pack",
        true
      );

      if (!importResult) {
        throw new Error("Failed to import private key");
      }

      // Wait for PastelID to be confirmed in the blockchain
      const pastelIDConfirmed = await this.waitForPastelIDRegistration(
        pack.pastel_id_pubkey
      );
      if (!pastelIDConfirmed) {
        throw new Error(
          `PastelID ${pack.pastel_id_pubkey} confirmation timed out`
        );
      }

      // Verify PastelID functionality
      const testMessage = "This is a test message for PastelID verification";
      const signature = await this.signMessageWithPastelID(
        pack.pastel_id_pubkey,
        testMessage,
        pack.pastel_id_passphrase
      );
      const verificationResult = await this.verifyMessageWithPastelID(
        pack.pastel_id_pubkey,
        testMessage,
        signature
      );

      if (!verificationResult) {
        throw new Error(
          `PastelID ${pack.pastel_id_pubkey} verification failed`
        );
      }

      // Verify Credit Pack Ticket
      const creditPackConfirmed = await this.waitForCreditPackConfirmation(
        pack.credit_pack_registration_txid
      );
      if (!creditPackConfirmed) {
        throw new Error(
          `Credit Pack Ticket ${pack.credit_pack_registration_txid} confirmation timed out`
        );
      }

      return {
        success: true,
        message: "Promotional pack imported and verified successfully",
        details: {
          pastelID: pack.pastel_id_pubkey,
          creditPackTxid: pack.credit_pack_registration_txid,
        },
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to import promotional pack: ${
          (error as Error).message
        }`,
      };
    }
  }

  private async storeSecureContainer(
    pastelID: string,
    secureContainer: string,
    network: string
  ): Promise<void> {
    localStorage.setItem(
      `secureContainer_${pastelID}_${network}`,
      secureContainer
    );
  }

  private async getLocalRPCSettings(): Promise<{ rpcport: string }> {
    const rpcport = localStorage.getItem("rpcport") || "9932"; // Default to mainnet
    return { rpcport };
  }

  async getBurnAddress(): Promise<string> {
    const { network } = await this.getNetworkInfo();
    switch (network) {
      case "Mainnet":
        return "PtpasteLBurnAddressXXXXXXXXXXbJ5ndd";
      case "Testnet":
        return "tPpasteLBurnAddressXXXXXXXXXXX3wy7u";
      case "Devnet":
        return "44oUgmZSL997veFEQDq569wv5tsT6KXf9QY7";
      default:
        throw new Error(`Unsupported network: ${network}`);
    }
  }

  async changeNetwork(
    newNetwork: string
  ): Promise<{ success: boolean; message: string }> {
    if (["Mainnet", "Testnet", "Devnet"].includes(newNetwork)) {
      await setNetworkInLocalStorage(newNetwork);
      await this.configureRPCAndSetBurnAddress();
      // Re-initialize connection with new network settings
      await this.initialize();
      return { success: true, message: `Network changed to ${newNetwork}` };
    } else {
      return { success: false, message: "Invalid network specified" };
    }
  }

  private async configureRPCAndSetBurnAddress(): Promise<{
    network: string;
    burnAddress: string;
  }> {
    let network = await getNetworkFromLocalStorage();
    if (!network) {
      network = "Mainnet";
      await setNetworkInLocalStorage(network);
    }

    let burnAddress: string;
    switch (network) {
      case "Mainnet":
        burnAddress = "PtpasteLBurnAddressXXXXXXXXXXbJ5ndd";
        break;
      case "Testnet":
        burnAddress = "tPpasteLBurnAddressXXXXXXXXXXX3wy7u";
        break;
      case "Devnet":
        burnAddress = "44oUgmZSL997veFEQDq569wv5tsT6KXf9QY7";
        break;
      default:
        throw new Error(`Unsupported network: ${network}`);
    }

    return { network, burnAddress };
  }

  async getNetworkInfo(): Promise<{ network: string }> {
    const network = await getNetworkFromLocalStorage();
    return { network };
  }
}

export default BrowserRPCReplacement;


---
./src/app/lib/PastelInferenceClient.ts
---
// src/app/lib/PastelInferenceClient.ts

'use client'

import BrowserRPCReplacement from "./BrowserRPCReplacement";
import { BrowserDatabase } from "./BrowserDatabase";
import * as utils from "./utils";
import * as validationSchemas from "./validationSchemas";
import browserLogger from "@/app/lib/logger";
import {
  PastelInferenceClientConfig,
  ChallengeResponse,
  UserMessage,
  ModelMenu,
  SupernodeResponse,
  ValidCreditPackTicket,
  BalanceInfo,
  CreditPackTicketInfo,
  CreditPackPurchaseRequest,
  PreliminaryPriceQuote,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackStorageRetryRequest,
  CreditPackStorageRetryRequestResponse,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackRequestStatusCheck,
  InferenceRequestData,
  InferenceAPIUsageResponse,
  InferenceAPIOutputResult,
  InferenceConfirmationData,
  CreditPackPurchaseRequestRejection,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestStatus,
  AuditResult 
} from "@/app/types";

const rpc = new BrowserRPCReplacement();
const db = new BrowserDatabase();

class PastelInferenceClient {
  private pastelID: string;
  private passphrase: string;

  constructor(config: PastelInferenceClientConfig) {
    this.pastelID = config.pastelID;
    this.passphrase = config.passphrase;
  }

  public getPastelID(): string {
    return this.pastelID;
  }

  private async requestAndSignChallenge(
    supernodeURL: string
  ): Promise<ChallengeResponse> {
    try {
      const response = await fetch(
        `${supernodeURL}/request_challenge/${this.pastelID}`
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const { challenge, challenge_id } = await response.json();
      const challenge_signature = await rpc.signMessageWithPastelID(
        this.pastelID,
        challenge,
        this.passphrase
      );
      return {
        challenge,
        challenge_id,
        challenge_signature,
      };
    } catch (error) {
      browserLogger.error(
        `Error requesting and signing challenge: ${utils.safeStringify(error)}`
      );
      throw error;
    }
  }

  async sendUserMessage(
    supernodeURL: string,
    userMessage: UserMessage
  ): Promise<UserMessage> {
    try {
      const validationResult =
        validationSchemas.userMessageSchema.safeParse(userMessage);
      if (!validationResult.success) {
        throw new Error(
          `Invalid user message: ${validationResult.error.message}`
        );
      }
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = userMessage;
      const response = await fetch(`${supernodeURL}/send_user_message`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_message: payload,
          challenge,
          challenge_id,
          challenge_signature,
        }),
      });
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      const validatedResult = validationSchemas.userMessageSchema.parse(result);
      await db.addData("UserMessage", validatedResult);
      return validatedResult;
    } catch (error) {
      console.error(
        `Error sending user message: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      throw error;
    }
  }

  async getUserMessages(supernodeURL: string): Promise<UserMessage[]> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = new URLSearchParams({
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      });
      const response = await fetch(
        `${supernodeURL}/get_user_messages?${params}`
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      const validatedResults = result.map((messageData: unknown) =>
        validationSchemas.userMessageSchema.parse(messageData)
      );
      await Promise.all(
        validatedResults.map((message: UserMessage) =>
          db.addData("UserMessage", message)
        )
      );
      return validatedResults;
    } catch (error) {
      console.error(
        `Error retrieving user messages: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      throw error;
    }
  }

  async getModelMenu(): Promise<ModelMenu> {
    const minimumNumberOfResponses = 5;
    const retryLimit = 1;
    try {
      const { validMasternodeListFullDF } = await rpc.checkSupernodeList();
      const closestSupernodes = await utils.getNClosestSupernodesToPastelIDURLs(
        60,
        this.pastelID,
        validMasternodeListFullDF
      );
      const validResponses: SupernodeResponse[] = [];

      await new Promise<void>((resolve, reject) => {
        let completedRequests = 0;
        closestSupernodes.forEach(({ url }) => {
          this.retryPromise(
            () => this.getModelMenuFromSupernode(url),
            retryLimit
          )
            .then((response) => {
              console.info(
                `Successful model menu response received from supernode at ${url}`
              );
              validResponses.push({ response, url });
              if (validResponses.length >= minimumNumberOfResponses) {
                resolve();
              }
            })
            .catch((error) => {
              console.error(
                `Error querying supernode at ${url}: ${
                  error instanceof Error ? error.message : String(error)
                }`
              );
              completedRequests++;
              if (
                completedRequests >
                closestSupernodes.length -
                  minimumNumberOfResponses +
                  validResponses.length
              ) {
                reject(
                  new Error(
                    "Insufficient valid responses received from supernodes"
                  )
                );
              }
            });
        });
      });

      const largestResponse = validResponses.reduce((prev, current) => {
        return JSON.stringify(current.response).length >
          JSON.stringify(prev.response).length
          ? current
          : prev;
      }).response as ModelMenu;

      return largestResponse;
    } catch (error) {
      console.error(
        `Error in getModelMenu: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      throw error;
    }
  }

  private async getModelMenuFromSupernode(
    supernodeURL: string
  ): Promise<ModelMenu | null> {
    try {
      const response = await fetch(`${supernodeURL}/get_inference_model_menu`);
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    } catch {
      return null;
    }
  }

  private async retryPromise<T>(
    promiseFunc: () => Promise<T>,
    limit: number,
    count = 0
  ): Promise<T> {
    try {
      return await promiseFunc();
    } catch (error) {
      if (count < limit) {
        return this.retryPromise(promiseFunc, limit, count + 1);
      } else {
        throw error;
      }
    }
  }

  async getValidCreditPackTicketsForPastelID(
    supernodeURL: string
  ): Promise<ValidCreditPackTicket[]> {
    const useVerbose = false;
    try {
      if (!this.pastelID) {
        return [];
      }
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      };
      if (useVerbose) {
        utils.logActionWithPayload(
          "retrieving",
          "valid credit pack tickets for PastelID",
          payload
        );
      }
      const response = await fetch(
        `${supernodeURL}/get_valid_credit_pack_tickets_for_pastelid`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );
      if (!response.ok) {
        if (useVerbose) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return [];
      }
      const validCreditPackTickets: ValidCreditPackTicket[] =
        await response.json();
      if (useVerbose && validCreditPackTickets.length) {
        console.info(
          `Received ${validCreditPackTickets.length} valid credit pack tickets for PastelID ${this.pastelID}`
        );
      }

      return validCreditPackTickets;
    } catch (error) {
      if (useVerbose) {
        console.error(
          `Error retrieving valid credit pack tickets for PastelID: ${
            error instanceof Error ? error.message : String(error)
          }`
        );
      }
      if (useVerbose) {
        throw error;
      }
      return [];
    }
  }

  async checkCreditPackBalance(
    supernodeURL: string,
    txid: string
  ): Promise<BalanceInfo> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        credit_pack_ticket_txid: txid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      utils.logActionWithPayload("checking", "credit pack balance", payload);

      const response = await fetch(
        `${supernodeURL}/check_credit_pack_balance`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const balanceInfo: BalanceInfo = await response.json();
      console.info(
        `Received credit pack balance info for txid ${txid}: ${JSON.stringify(
          balanceInfo
        )}`
      );
      return balanceInfo;
    } catch (error) {
      console.error(
        `Error checking credit pack balance for txid ${txid}: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      throw error;
    }
  }

  async getCreditPackTicketFromTxid(
    supernodeURL: string,
    txid: string
  ): Promise<CreditPackTicketInfo> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = new URLSearchParams({
        txid,
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      });
      utils.logActionWithPayload(
        "retrieving",
        "credit pack ticket from txid",
        params
      );

      const response = await fetch(
        `${supernodeURL}/get_credit_pack_ticket_from_txid?${params}`
      );

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const {
        credit_pack_purchase_request_response,
        credit_pack_purchase_request_confirmation,
      } = await response.json();

      utils.logActionWithPayload(
        "received",
        "credit pack ticket from Supernode",
        {
          credit_pack_purchase_request_response,
          credit_pack_purchase_request_confirmation,
        }
      );

      const validatedRequestResponse =
        validationSchemas.creditPackPurchaseRequestResponseSchema.parse(
          credit_pack_purchase_request_response
        );
      const validatedRequestConfirmation = validationSchemas.creditPackPurchaseRequestConfirmationSchema.parse(
        credit_pack_purchase_request_confirmation
  );

  return {
    requestResponse: validatedRequestResponse,
    requestConfirmation: {
      ...validatedRequestConfirmation,
      id: parseInt(validatedRequestConfirmation.id, 10)
    },
    balanceInfo: {
      credit_pack_current_credit_balance: 0,
      balance_as_of_datetime: new Date().toISOString(),
    },
  };
    } catch (error) {
      console.error(
        `Error retrieving credit pack ticket from txid: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      throw error;
    }
  }

  async creditPackTicketInitialPurchaseRequest(
    supernodeURL: string,
    creditPackRequest: CreditPackPurchaseRequest
  ): Promise<PreliminaryPriceQuote | CreditPackPurchaseRequestRejection> {
    try {
      const validatedCreditPackRequest =
        validationSchemas.creditPackPurchaseRequestSchema.parse(
          creditPackRequest
        );
      await db.addData("CreditPackPurchaseRequest", validatedCreditPackRequest);
      utils.logActionWithPayload(
        "requesting",
        "a new Pastel credit pack ticket",
        validatedCreditPackRequest
      );
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
        const preparedCreditPackRequest = await utils.prepareModelForEndpoint(
          validatedCreditPackRequest
        );
      const response = await fetch(
        `${supernodeURL}/credit_purchase_initial_request`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            challenge,
            challenge_id,
            challenge_signature,
            credit_pack_request: preparedCreditPackRequest,
          }),
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();

      if ("rejection_reason_string" in result) {
        console.error(
          `Credit pack purchase request rejected: ${result.rejection_reason_string}`
        );
        const rejectionResponse = await utils.prepareModelForValidation(result);
        const validatedRejection =
          validationSchemas.creditPackPurchaseRequestRejectionSchema.parse(
            rejectionResponse
          );
        await db.addData(
          "CreditPackPurchaseRequestRejection",
          validatedRejection
        );
        return validatedRejection;
      } else {
        utils.logActionWithPayload(
          "receiving",
          "response to credit pack purchase request",
          result
        );
        const preparedResult = await utils.prepareModelForValidation(result);
        const validatedPriceQuote =
          validationSchemas.creditPackPurchaseRequestPreliminaryPriceQuoteSchema.parse(
            preparedResult
          );
        await db.addData(
          "CreditPackPurchaseRequestPreliminaryPriceQuote",
          validatedPriceQuote
        );
        return validatedPriceQuote;
      }
    } catch (error) {
      console.error(
        `Error initiating credit pack ticket purchase: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  private async calculatePriceDifferencePercentage(
    quotedPrice: number,
    estimatedPrice: number
  ): Promise<number> {
    if (estimatedPrice === 0) {
      throw new Error("Estimated price cannot be zero.");
    }
    return Math.abs(quotedPrice - estimatedPrice) / estimatedPrice;
  }

  private async confirmPreliminaryPriceQuote(
    preliminaryPriceQuote: PreliminaryPriceQuote,
    maximumTotalCreditPackPriceInPSL: number,
    maximumPerCreditPriceInPSL: number
  ): Promise<boolean> {
    if (!maximumTotalCreditPackPriceInPSL && !maximumPerCreditPriceInPSL) {
      maximumPerCreditPriceInPSL = parseFloat(
        localStorage.getItem("MAXIMUM_PER_CREDIT_PRICE_IN_PSL_FOR_CLIENT") ||
          "0.1"
      );
    }
    const {
      preliminary_quoted_price_per_credit_in_psl: quotedPricePerCredit,
      preliminary_total_cost_of_credit_pack_in_psl: quotedTotalPrice,
      credit_pack_purchase_request_fields_json_b64: requestFieldsB64,
    } = preliminaryPriceQuote;
    const requestFields = JSON.parse(atob(requestFieldsB64));
    const { requested_initial_credits_in_credit_pack: requestedCredits } =
      requestFields;
    if (!maximumTotalCreditPackPriceInPSL) {
      maximumTotalCreditPackPriceInPSL =
        maximumPerCreditPriceInPSL * requestedCredits;
    } else if (!maximumPerCreditPriceInPSL) {
      maximumPerCreditPriceInPSL =
        maximumTotalCreditPackPriceInPSL / requestedCredits;
    }
    const estimatedPricePerCredit =
      await utils.estimatedMarketPriceOfInferenceCreditsInPSLTerms();
    const priceDifferencePercentage =
      await this.calculatePriceDifferencePercentage(
        quotedPricePerCredit,
        estimatedPricePerCredit
      );

    const MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING =
      parseFloat(
        localStorage.getItem(
          "MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING"
        ) || "0.001"
      );

    const numberFormat = new Intl.NumberFormat("en-US");
    const percentageFormat = (value: number) => value.toFixed(2);

    if (
      quotedPricePerCredit <= maximumPerCreditPriceInPSL &&
      quotedTotalPrice <= maximumTotalCreditPackPriceInPSL &&
      priceDifferencePercentage <=
        MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING
    ) {
      console.info(
        `Preliminary price quote is within the acceptable range: ${numberFormat.format(
          quotedPricePerCredit
        )} PSL per credit, ${numberFormat.format(
          quotedTotalPrice
        )} PSL total, which is within the maximum of ${numberFormat.format(
          maximumPerCreditPriceInPSL
        )} PSL per credit and ${numberFormat.format(
          maximumTotalCreditPackPriceInPSL
        )} PSL total. The price difference from the estimated fair market price is ${percentageFormat(
          priceDifferencePercentage * 100
        )}%, which is within the allowed maximum of ${percentageFormat(
          MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING * 100
        )}%. Please be patient while the new credit pack request is initialized.`
      );
      return true;
    } else {
      console.warn(
        `Preliminary price quote exceeds the maximum acceptable price or the price difference from the estimated fair price is too high! Quoted price: ${numberFormat.format(
          quotedPricePerCredit
        )} PSL per credit, ${numberFormat.format(
          quotedTotalPrice
        )} PSL total, maximum price: ${numberFormat.format(
          maximumPerCreditPriceInPSL
        )} PSL per credit, ${numberFormat.format(
          maximumTotalCreditPackPriceInPSL
        )} PSL total. The price difference from the estimated fair market price is ${percentageFormat(
          priceDifferencePercentage * 100
        )}%, which exceeds the allowed maximum of ${percentageFormat(
          MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING * 100
        )}%.`
      );
      return false;
    }
  }

  async internalEstimateOfCreditPackTicketCostInPSL(
    desiredNumberOfCredits: number,
    priceCushionPercentage: number
  ): Promise<number> {
    const estimatedPricePerCredit =
      await utils.estimatedMarketPriceOfInferenceCreditsInPSLTerms();
    return (
      Math.round(
        desiredNumberOfCredits *
          estimatedPricePerCredit *
          (1 + priceCushionPercentage) *
          100
      ) / 100
    );
  }

  async creditPackTicketPreliminaryPriceQuoteResponse(
    supernodeURL: string,
    creditPackRequest: CreditPackPurchaseRequest,
    preliminaryPriceQuote: PreliminaryPriceQuote,
    maximumTotalCreditPackPriceInPSL: number,
    maximumPerCreditPriceInPSL: number
  ): Promise<
    | CreditPackPurchaseRequestResponse
    | CreditPackPurchaseRequestResponseTermination
  > {
    try {
      if ("rejection_reason_string" in preliminaryPriceQuote) {
        console.error(
          `Credit pack purchase request rejected: ${preliminaryPriceQuote.rejection_reason_string}`
        );
return preliminaryPriceQuote as unknown as CreditPackPurchaseRequestResponseTermination;
      }

      const agreeWithPriceQuote = await this.confirmPreliminaryPriceQuote(
        preliminaryPriceQuote,
        maximumTotalCreditPackPriceInPSL,
        maximumPerCreditPriceInPSL
      );

      console.info(
        `Agree with price quote: ${agreeWithPriceQuote}; responding to preliminary price quote to Supernode at ${supernodeURL}...`
      );
      const priceQuoteResponse = {
        sha3_256_hash_of_credit_pack_purchase_request_fields:
          creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
        sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
          preliminaryPriceQuote.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields,
        credit_pack_purchase_request_fields_json_b64:
          preliminaryPriceQuote.credit_pack_purchase_request_fields_json_b64,
        agree_with_preliminary_price_quote: agreeWithPriceQuote,
        credit_usage_tracking_psl_address:
          preliminaryPriceQuote.credit_usage_tracking_psl_address,
        preliminary_quoted_price_per_credit_in_psl: parseFloat(
          preliminaryPriceQuote.preliminary_quoted_price_per_credit_in_psl.toString()
        ),
        preliminary_price_quote_response_timestamp_utc_iso_string:
          new Date().toISOString(),
        preliminary_price_quote_response_pastel_block_height:
          await rpc.getCurrentPastelBlockHeight(),
        preliminary_price_quote_response_message_version_string: "1.0",
        requesting_end_user_pastelid:
          creditPackRequest.requesting_end_user_pastelid,
        sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields:
          "",
        requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash:
          "",
      };

      // Compute hashes and signatures
      priceQuoteResponse.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields =
        await utils.computeSHA3256HashOfSQLModelResponseFields(
          priceQuoteResponse
        );
      priceQuoteResponse.requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash =
        await rpc.signMessageWithPastelID(
          creditPackRequest.requesting_end_user_pastelid,
          priceQuoteResponse.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields,
          this.passphrase
        );

      // Validate the price quote response
      const validatedPriceQuoteResponse =
        validationSchemas.creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema.parse(
          priceQuoteResponse
        );

      // Prepare model for endpoint before sending
      const preparedPriceQuoteResponse = await utils.prepareModelForEndpoint(
        validatedPriceQuoteResponse
      );

      delete preparedPriceQuoteResponse.id;
      preparedPriceQuoteResponse.agree_with_preliminary_price_quote =
        preparedPriceQuoteResponse.agree_with_preliminary_price_quote ? 1 : 0;

      // Prepare and send the payload to the supernode
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const completePriceQuoteResponse = {
        challenge,
        challenge_id,
        challenge_signature,
        preliminary_price_quote_response: preparedPriceQuoteResponse,
      };

      const response = await fetch(
        `${supernodeURL}/credit_purchase_preliminary_price_quote_response`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(completePriceQuoteResponse),
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();

      if ("termination_reason_string" in result) {
        console.error(
          `Credit pack purchase request response terminated: ${result.termination_reason_string}`
        );
        const terminationResponse = await utils.prepareModelForValidation(
          result
        );
        const validatedTermination =
          validationSchemas.creditPackPurchaseRequestResponseTerminationSchema.parse(
            terminationResponse
          );
        await db.addData(
          "CreditPackPurchaseRequestResponseTermination",
          validatedTermination
        );
        return validatedTermination;
      } else {
        const transformedResult =
          utils.transformCreditPackPurchaseRequestResponse(
            await utils.prepareModelForValidation(result)
          );
        utils.logActionWithPayload(
          "receiving",
          "response to credit pack purchase request",
          transformedResult
        );
        const validatedResponse = validationSchemas.creditPackPurchaseRequestResponseSchema.parse(
          transformedResult as CreditPackPurchaseRequestResponse
        );
        await db.addData(
          "CreditPackPurchaseRequestResponse",
          validatedResponse
        );
        return validatedResponse;
      }
    } catch (error) {
      console.error(
        `Error responding to preliminary price quote: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async confirmCreditPurchaseRequest(
    supernodeURL: string,
    creditPackPurchaseRequestConfirmation: CreditPackPurchaseRequestConfirmation
  ): Promise<CreditPackPurchaseRequestConfirmationResponse> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = await utils.prepareModelForEndpoint(
        creditPackPurchaseRequestConfirmation
      );
      utils.logActionWithPayload(
        "confirming",
        "credit pack purchase request",
        payload
      );
      const response = await fetch(
        `${supernodeURL}/confirm_credit_purchase_request`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            confirmation: payload,
            challenge,
            challenge_id,
            challenge_signature,
          }),
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      utils.logActionWithPayload(
        "receiving",
        "response to credit pack purchase confirmation",
        result
      );
      const validatedResult = validationSchemas.creditPackPurchaseRequestConfirmationResponseSchema.parse(result);
      await db.addData(
        "CreditPackPurchaseRequestConfirmationResponse",
        validatedResult
      );
      return validatedResult as CreditPackPurchaseRequestConfirmationResponse;
    } catch (error) {
      console.error(
        `Error confirming credit pack purchase request: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async checkStatusOfCreditPurchaseRequest(
    supernodeURL: string,
    creditPackPurchaseRequestHash: string
  ): Promise<CreditPackPurchaseRequestStatus> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const statusCheck = {
        sha3_256_hash_of_credit_pack_purchase_request_fields:
          creditPackPurchaseRequestHash,
        requesting_end_user_pastelid: this.pastelID,
        requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields:
          await rpc.signMessageWithPastelID(
            this.pastelID,
            creditPackPurchaseRequestHash,
            this.passphrase
          ),
      };
      const validatedStatusCheck =
        validationSchemas.creditPackRequestStatusCheckSchema.parse(statusCheck);
        delete (validatedStatusCheck as Partial<CreditPackRequestStatusCheck>).id;

      utils.logActionWithPayload(
        "checking",
        "status of credit pack purchase request",
        validatedStatusCheck
      );
      const response = await fetch(
        `${supernodeURL}/check_status_of_credit_purchase_request`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            credit_pack_request_status_check: validatedStatusCheck,
            challenge,
            challenge_id,
            challenge_signature,
          }),
        }
      );
      if (!response.ok) {
        throw new Error(
          `HTTP error ${response.status}: ${response.statusText}`
        );
      }
      const responseData = await response.json();
      utils.logActionWithPayload(
        "receiving",
        "credit pack purchase request response from Supernode",
        responseData
      );
      const transformedResult = await utils.prepareModelForValidation(
        responseData
      );
      delete (transformedResult as Partial<InferenceAPIUsageResponse>).id;
      const validatedResult =
        validationSchemas.creditPackPurchaseRequestStatusSchema.parse(
          transformedResult
        );
      await db.addData("CreditPackPurchaseRequestStatus", validatedResult);
      return validatedResult;
    } catch (error) {
      console.error(
        `Error checking status of credit purchase request: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async creditPackPurchaseCompletionAnnouncement(
    supernodeURL: string,
    creditPackPurchaseRequestConfirmation: CreditPackPurchaseRequestConfirmation
  ): Promise<void> {
    try {
      const validatedConfirmation =
        validationSchemas.creditPackPurchaseRequestConfirmationSchema.parse(
          creditPackPurchaseRequestConfirmation
        );

      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = { ...validatedConfirmation };
      delete (payload as Partial<typeof validatedConfirmation>).id;

      const response = await fetch(
        `${supernodeURL}/credit_pack_purchase_completion_announcement`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            confirmation: payload,
            challenge,
            challenge_id,
            challenge_signature,
          }),
        }
      );
      if (!response.ok) {
        console.error(`HTTP error ${response.status}: ${response.statusText}`);
      } else {
        console.info(
          `Credit pack purchase completion announcement sent successfully to ${supernodeURL}`
        );
      }
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        console.error(
          `Timeout error sending credit pack purchase completion announcement to ${supernodeURL}: ${error.message}`
        );
      } else {
        console.error(
          `Error sending credit pack purchase completion announcement to ${supernodeURL}: ${
            error instanceof Error ? error.message : String(error)
          }`
        );
      }
    }
  }

  async creditPackStorageRetryRequest(
    supernodeURL: string,
    creditPackStorageRetryRequest: CreditPackStorageRetryRequest
  ): Promise<CreditPackStorageRetryRequestResponse> {
    try {
      const validatedRequest =
        validationSchemas.creditPackStorageRetryRequestSchema.parse(
          creditPackStorageRetryRequest
        );

      await db.addData("CreditPackStorageRetryRequest", validatedRequest);

      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await utils.prepareModelForEndpoint(validatedRequest);
      utils.logActionWithPayload(
        "sending",
        "credit pack storage retry request",
        payload
      );

      const response = await fetch(
        `${supernodeURL}/credit_pack_storage_retry_request`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            request: payload,
            challenge,
            challenge_id,
            challenge_signature,
          }),
        }
      );

      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      utils.logActionWithPayload(
        "receiving",
        "response to credit pack storage retry request",
        result
      );

      const transformedResult = await utils.prepareModelForValidation(result);
      const validatedResponse =
        validationSchemas.creditPackStorageRetryRequestResponseSchema.parse(
          transformedResult
        );

      await db.addData(
        "CreditPackStorageRetryRequestResponse",
        validatedResponse
      );
      return validatedResponse;
    } catch (error) {
      console.error(
        `Error sending credit pack storage retry request: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async creditPackStorageRetryCompletionAnnouncement(
    supernodeURL: string,
    creditPackStorageRetryRequestResponse: CreditPackStorageRetryRequestResponse
  ): Promise<void> {
    try {
      const validatedResponse =
        validationSchemas.creditPackStorageRetryRequestResponseSchema.parse(
          creditPackStorageRetryRequestResponse
        );

      await db.addData(
        "CreditPackStorageRetryRequestResponse",
        validatedResponse
      );

      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await utils.prepareModelForEndpoint(validatedResponse);
      utils.logActionWithPayload(
        "sending",
        "storage retry completion announcement message",
        payload
      );

      const response = await fetch(
        `${supernodeURL}/credit_pack_storage_retry_completion_announcement`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            response: payload,
            challenge,
            challenge_id,
            challenge_signature,
          }),
        }
      );

      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
    } catch (error) {
      console.error(
        `Error sending credit pack storage retry completion announcement: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async retrieveCreditPackTicketFromPurchaseBurnTxid(
    supernodeURL: string,
    txid: string
  ): Promise<unknown> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        purchase_burn_txid: txid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      utils.logActionWithPayload(
        "retrieving",
        "credit pack ticket from purchase burn txid",
        payload
      );

      const response = await fetch(
        `${supernodeURL}/retrieve_credit_pack_ticket_from_purchase_burn_txid`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok)
        throw new Error(`HTTP error! Status: ${response.status}`);

      const ticketInfo = await response.json();
      console.info(
        `Received credit pack ticket for purchase burn txid ${txid}: ${JSON.stringify(
          ticketInfo
        )}`
      );
      return ticketInfo;
    } catch (error) {
      console.error(
        `Error retrieving credit pack ticket for purchase burn txid ${txid}: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      throw error;
    }
  }

  async getFinalCreditPackRegistrationTxidFromPurchaseBurnTxid(
    supernodeURL: string,
    purchaseBurnTxid: string
  ): Promise<string> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        purchase_burn_txid: purchaseBurnTxid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      utils.logActionWithPayload(
        "retrieving",
        "final credit pack registration txid",
        payload
      );

      const response = await fetch(
        `${supernodeURL}/get_final_credit_pack_registration_txid_from_credit_purchase_burn_txid`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );

      if (!response.ok)
        throw new Error(`HTTP error! Status: ${response.status}`);

      const responseData = await response.json();
      const finalTxid = responseData.final_credit_pack_registration_txid;
      console.info(
        `Received final credit pack registration txid for purchase burn txid ${purchaseBurnTxid}: ${finalTxid}`
      );
      return finalTxid;
    } catch (error) {
      console.error(
        `Error retrieving final credit pack registration txid for purchase burn txid ${purchaseBurnTxid}: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
      throw error;
    }
  }

  async makeInferenceAPIUsageRequest(
    supernodeURL: string,
    requestData: InferenceRequestData
  ): Promise<InferenceAPIUsageResponse> {
    try {
      const validatedRequest =
        validationSchemas.inferenceAPIUsageRequestSchema.parse(requestData);
      delete (validatedRequest as Partial<InferenceRequestData>).id;
      await db.addData("InferenceAPIUsageRequest", validatedRequest);
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      utils.logActionWithPayload(
        "making",
        "inference usage request",
        validatedRequest
      );
      const response = await fetch(
        `${supernodeURL}/make_inference_api_usage_request`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            inference_api_usage_request: validatedRequest,
            challenge,
            challenge_id,
            challenge_signature,
          }),
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      utils.logActionWithPayload(
        "received",
        "response to inference usage request",
        result
      );
      const transformedResult = await utils.prepareModelForValidation(result);
      delete (transformedResult as Partial<InferenceAPIUsageResponse>).id;
      const validatedResponse =
        validationSchemas.inferenceAPIUsageResponseSchema.parse(
          transformedResult
        );
      await db.addData("InferenceAPIUsageResponse", validatedResponse);
      return validatedResponse;
    } catch (error) {
      console.error(
        `Error making inference API usage request: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async sendInferenceConfirmation(
    supernodeURL: string,
    confirmationData: InferenceConfirmationData
  ): Promise<unknown> {
    try {
      const confirmationDataJSON = { ...confirmationData };
      delete (confirmationDataJSON as Partial<InferenceConfirmationData>).id;

      const validatedConfirmation =
        validationSchemas.inferenceConfirmationSchema.parse(
          confirmationDataJSON
        );
      await db.addData("InferenceConfirmation", validatedConfirmation);
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await utils.prepareModelForEndpoint(
        validatedConfirmation
      );
      utils.logActionWithPayload("sending", "inference confirmation", payload);
      const response = await fetch(
        `${supernodeURL}/confirm_inference_request`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            inference_confirmation: confirmationDataJSON,
            challenge,
            challenge_id,
            challenge_signature,
          }),
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      utils.logActionWithPayload(
        "receiving",
        "response to inference confirmation",
        result
      );

      return result;
    } catch (error) {
      console.error(
        `Error sending inference confirmation: ${utils.safeStringify(error)}`
      );
      throw error;
    }
  }

  async checkStatusOfInferenceRequestResults(
    supernodeURL: string,
    inferenceResponseID: string
  ): Promise<boolean> {
    try {
      console.info(
        `Checking status of inference request results for ID ${inferenceResponseID}`
      );

      const response = await fetch(
        `${supernodeURL}/check_status_of_inference_request_results/${inferenceResponseID}`
      );

      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      utils.logActionWithPayload(
        "receiving",
        `status of inference request results for ID ${inferenceResponseID}`,
        result
      );

      return typeof result === "boolean" ? result : false;
    } catch (error) {
      console.error(
        `Error checking status of inference request results from Supernode URL: ${supernodeURL}: ${utils.safeStringify(
          error
        )}`
      );
      return false;
    }
  }

  async retrieveInferenceOutputResults(
    supernodeURL: string,
    inferenceRequestID: string,
    inferenceResponseID: string
  ): Promise<InferenceAPIOutputResult> {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = new URLSearchParams({
        inference_response_id: inferenceResponseID,
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      });
      utils.logActionWithPayload(
        "attempting",
        `to retrieve inference output results for response ID ${inferenceResponseID}`,
        params
      );
      const response = await fetch(
        `${supernodeURL}/retrieve_inference_output_results?${params}`,
        {
          method: "POST",
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      delete (result as Partial<InferenceAPIUsageResponse>).id;
      utils.logActionWithPayload(
        "receiving",
        "inference output results",
        result
      );
      const transformedResult = await utils.prepareModelForValidation(result);
      const validatedResult =
        validationSchemas.inferenceAPIOutputResultSchema.parse(
          transformedResult
        );
      await db.addData("InferenceAPIOutputResult", validatedResult);
      return validatedResult;
    } catch (error) {
      console.error(
        `Error retrieving inference output results: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async callAuditInferenceRequestResponse(
    supernodeURL: string,
    inferenceResponseID: string
  ): Promise<InferenceAPIUsageResponse> {
    try {
      const signature = await rpc.signMessageWithPastelID(
        this.pastelID,
        inferenceResponseID,
        this.passphrase
      );
      const payload = {
        inference_response_id: inferenceResponseID,
        pastel_id: this.pastelID,
        signature,
      };
      const response = await fetch(
        `${supernodeURL}/audit_inference_request_response`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      delete (result as Partial<InferenceAPIOutputResult>).id;
      const transformedResult = await utils.prepareModelForValidation(result);
      const validatedResult =
        validationSchemas.inferenceAPIUsageResponseSchema.parse(
          transformedResult
        );
      return validatedResult;
    } catch (error) {
      console.error(
        `Error calling audit inference request response from Supernode URL: ${supernodeURL}: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async callAuditInferenceRequestResult(
    supernodeURL: string,
    inferenceResponseID: string
  ): Promise<InferenceAPIOutputResult> {
    try {
      const signature = await rpc.signMessageWithPastelID(
        this.pastelID,
        inferenceResponseID,
        this.passphrase
      );
      const payload = {
        inference_response_id: inferenceResponseID,
        pastel_id: this.pastelID,
        signature,
      };
      const response = await fetch(
        `${supernodeURL}/audit_inference_request_result`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const result = await response.json();
      delete (result as Partial<InferenceAPIOutputResult>).id;
      const transformedResult = await utils.prepareModelForValidation(result);
      const validatedResult =
        validationSchemas.inferenceAPIOutputResultSchema.parse(
          transformedResult
        );
      return validatedResult;
    } catch (error) {
      console.error(
        `Error calling audit inference request result from Supernode URL: ${supernodeURL}: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async auditInferenceRequestResponseID(
    inferenceResponseID: string
  ): Promise<AuditResult[]> {
    try {
      const { validMasternodeListFullDF } = await rpc.checkSupernodeList();
      const filteredSupernodes = await utils.filterSupernodes(
        validMasternodeListFullDF
      );
  
      const supernodeURLsAndPastelIDs = filteredSupernodes.slice(0, 5);
  
      const listOfSupernodeURLs = supernodeURLsAndPastelIDs.map(
        (supernode) => `http://${supernode.ipaddress_port.split(":")[0]}:7123`
      );
  
      const responseAuditTasks = listOfSupernodeURLs.map((url) =>
        this.callAuditInferenceRequestResponse(url, inferenceResponseID)
      );
      const responseAuditResults = await Promise.all(responseAuditTasks);
  
      await new Promise((resolve) => setTimeout(resolve, 20000));
  
      const resultAuditTasks = listOfSupernodeURLs.map((url) =>
        this.callAuditInferenceRequestResult(url, inferenceResponseID)
      );
      const resultAuditResults = await Promise.all(resultAuditTasks);
  
      const auditResults: AuditResult[] = responseAuditResults.map((response, index) => ({
        ...response,
        ...resultAuditResults[index],
      }));
  
      return auditResults;
    } catch (error) {
      console.error(
        `Error auditing inference request response ID: ${utils.safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async checkIfSupernodeSupportsDesiredModel(
    supernodeURL: string,
    modelCanonicalString: string,
    modelInferenceTypeString: string,
    modelParametersJSON: string
  ): Promise<boolean> {
    try {
      const response = await fetch(`${supernodeURL}/get_inference_model_menu`);
      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);
      const modelMenu: ModelMenu = await response.json();
      const desiredParameters = JSON.parse(modelParametersJSON);

      for (const model of modelMenu.models) {
        if (
          model.model_name === modelCanonicalString &&
          model.supported_inference_type_strings.includes(
            modelInferenceTypeString
          )
        ) {
          const unsupportedParameters: string[] = [];

          for (const [desiredParam, desiredValue] of Object.entries(
            desiredParameters
          )) {
            let paramFound = false;

            for (const param of model.model_parameters) {
              if (
                param.name === desiredParam &&
                param.inference_types_parameter_applies_to.includes(
                  modelInferenceTypeString
                )
              ) {
                if ("type" in param) {
                  if (
                    param.type === "int" &&
                    Number.isInteger(Number(desiredValue))
                  ) {
                    paramFound = true;
                  } else if (
                    param.type === "float" &&
                    !isNaN(parseFloat(desiredValue as string))
                  ) {
                    paramFound = true;
                  } else if (
                    param.type === "string" &&
                    typeof desiredValue === "string"
                  ) {
                    if (
                      "options" in param &&
                      Array.isArray(param.options) &&
                      param.options.includes(desiredValue)
                    ) {
                      paramFound = true;
                    } else if (!("options" in param)) {
                      paramFound = true;
                    }
                  }
                } else {
                  paramFound = true;
                }
                break;
              }
            }

            if (!paramFound) {
              unsupportedParameters.push(desiredParam);
            }
          }

          if (unsupportedParameters.length === 0) {
            return true;
          } else {
            const unsupportedParamStr = unsupportedParameters.join(", ");
            console.error(
              `Unsupported model parameters for ${modelCanonicalString}: ${unsupportedParamStr}`
            );
            return false;
          }
        }
      }
      return false;
    } catch {
      return false;
    }
  }

  async getClosestSupernodeURLsThatSupportsDesiredModel(
    desiredModelCanonicalString: string,
    desiredModelInferenceTypeString: string,
    desiredModelParametersJSON: string,
    N = 12
  ): Promise<string[]> {
    const timeoutPeriod = 3000;

    try {
      const { validMasternodeListFullDF } = await rpc.checkSupernodeList();
      const filteredSupernodes = await utils.filterSupernodes(
        validMasternodeListFullDF
      );

      const checkSupernodePromises = filteredSupernodes.map((supernode) => {
        const startTime = Date.now();
        const url = `http://${supernode.ipaddress_port.split(":")[0]}:7123`;

        return Promise.race([
          this.checkIfSupernodeSupportsDesiredModel(
            url,
            desiredModelCanonicalString,
            desiredModelInferenceTypeString,
            desiredModelParametersJSON
          ).then((result) => ({
            result,
            url,
            responseTime: Date.now() - startTime,
          })),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error("Timeout")), timeoutPeriod)
          ),
        ]).catch(() => null);
      });

      const results = await Promise.allSettled(checkSupernodePromises);

      const validResponses = results
        .filter(
          (
            res
          ): res is PromiseFulfilledResult<{
            result: boolean;
            url: string;
            responseTime: number;
          }> => res.status === "fulfilled" && res.value !== null
        )
        .map((res) => res.value);

      const sortedResponses = validResponses.sort(
        (a, b) => a.responseTime - b.responseTime
      );

      return sortedResponses.slice(0, N).map((response) => response.url);
    } catch (error) {
      throw new Error(
        `Failed to get closest supernodes: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }
}

export default PastelInferenceClient;


---
./src/app/lib/BrowserDatabase.ts
---
// src/app/lib/BrowserDatabase.ts

'use client'

import {
  SupernodeList,
  Message,
  UserMessage,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestRejection,
  CreditPackPurchaseRequestPreliminaryPriceQuote,
  CreditPackPurchaseRequestPreliminaryPriceQuoteResponse,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackRequestStatusCheck,
  CreditPackPurchaseRequestStatus,
  CreditPackStorageRetryRequest,
  CreditPackStorageRetryRequestResponse,
  InferenceAPIUsageRequest,
  InferenceAPIUsageResponse,
  InferenceAPIOutputResult,
  InferenceConfirmation,
} from "@/app/types";

export class BrowserDatabase {
  private db: IDBDatabase | null = null;
  private readonly dbName = "PastelInferenceClientDB";
  private readonly dbVersion = 1;

  constructor() {}

  async initializeDatabase(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);

      request.onerror = (event: Event) => {
        console.error(
          "Error opening database:",
          (event.target as IDBOpenDBRequest).error
        );
        reject((event.target as IDBOpenDBRequest).error);
      };

      request.onsuccess = (event: Event) => {
        this.db = (event.target as IDBOpenDBRequest).result;
        console.log("Database opened successfully");
        resolve();
      };

      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
        this.db = (event.target as IDBOpenDBRequest).result;
        this.createObjectStores(this.db);
      };
    });
  }

  private createObjectStores(db: IDBDatabase): void {
    const storeDefinitions = [
      {
        storeName: "SupernodeList",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "txid_vout",
            keyPath: "txid_vout",
            options: { unique: false },
          },
          {
            name: "supernode_psl_address",
            keyPath: "supernode_psl_address",
            options: { unique: false },
          },
        ],
      },
      {
        storeName: "Message",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "UserMessage",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "CreditPackPurchaseRequest",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "sha3_256_hash_of_credit_pack_purchase_request_fields",
            keyPath: "sha3_256_hash_of_credit_pack_purchase_request_fields",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "CreditPackPurchaseRequestRejection",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "CreditPackPurchaseRequestPreliminaryPriceQuote",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "CreditPackPurchaseRequestPreliminaryPriceQuoteResponse",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "CreditPackPurchaseRequestResponseTermination",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "CreditPackPurchaseRequestResponse",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "sha3_256_hash_of_credit_pack_purchase_request_response_fields",
            keyPath:
              "sha3_256_hash_of_credit_pack_purchase_request_response_fields",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "CreditPackPurchaseRequestConfirmation",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields",
            keyPath:
              "sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "CreditPackPurchaseRequestConfirmationResponse",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "sha3_256_hash_of_credit_pack_purchase_request_confirmation_response_fields",
            keyPath:
              "sha3_256_hash_of_credit_pack_purchase_request_confirmation_response_fields",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "CreditPackRequestStatusCheck",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "CreditPackPurchaseRequestStatus",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "sha3_256_hash_of_credit_pack_purchase_request_status_fields",
            keyPath:
              "sha3_256_hash_of_credit_pack_purchase_request_status_fields",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "CreditPackStorageRetryRequest",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "CreditPackStorageRetryRequestResponse",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
      {
        storeName: "InferenceAPIUsageRequest",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "inference_request_id",
            keyPath: "inference_request_id",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "InferenceAPIUsageResponse",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "inference_response_id",
            keyPath: "inference_response_id",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "InferenceAPIOutputResult",
        keyPath: "id",
        autoIncrement: true,
        indexes: [
          {
            name: "inference_result_id",
            keyPath: "inference_result_id",
            options: { unique: true },
          },
        ],
      },
      {
        storeName: "InferenceConfirmation",
        keyPath: "id",
        autoIncrement: true,
        indexes: [],
      },
    ];

    storeDefinitions.forEach((storeDef) => {
      if (!db.objectStoreNames.contains(storeDef.storeName)) {
        const store = db.createObjectStore(storeDef.storeName, {
          keyPath: storeDef.keyPath,
          autoIncrement: storeDef.autoIncrement,
        });
        storeDef.indexes.forEach((index) => {
          store.createIndex(index.name, index.keyPath, index.options);
        });
      }
    });
  }

  async addData<T>(storeName: string, data: T): Promise<IDBValidKey> {
    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error("Database not initialized"));
        return;
      }

      const transaction = this.db.transaction([storeName], "readwrite");
      const store = transaction.objectStore(storeName);
      const request = store.add(data);

      request.onerror = (event) => {
        reject((event.target as IDBRequest).error);
      };

      request.onsuccess = (event) => {
        resolve((event.target as IDBRequest).result);
      };
    });
  }

  async getData<T>(storeName: string, id: IDBValidKey): Promise<T | undefined> {
    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error("Database not initialized"));
        return;
      }

      const transaction = this.db.transaction([storeName], "readonly");
      const store = transaction.objectStore(storeName);
      const request = store.get(id);

      request.onerror = (event) => {
        reject((event.target as IDBRequest).error);
      };

      request.onsuccess = (event) => {
        resolve((event.target as IDBRequest).result as T);
      };
    });
  }

  async updateData<T>(
    storeName: string,
    id: IDBValidKey,
    data: T
  ): Promise<IDBValidKey> {
    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error("Database not initialized"));
        return;
      }

      const transaction = this.db.transaction([storeName], "readwrite");
      const store = transaction.objectStore(storeName);
      const request = store.put({ ...data, id });

      request.onerror = (event) => {
        reject((event.target as IDBRequest).error);
      };

      request.onsuccess = (event) => {
        resolve((event.target as IDBRequest).result);
      };
    });
  }

  async deleteData(storeName: string, id: IDBValidKey): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error("Database not initialized"));
        return;
      }

      const transaction = this.db.transaction([storeName], "readwrite");
      const store = transaction.objectStore(storeName);
      const request = store.delete(id);

      request.onerror = (event) => {
        reject((event.target as IDBRequest).error);
      };

      request.onsuccess = () => {
        resolve();
      };
    });
  }

  async getAllData<T>(storeName: string): Promise<T[]> {
    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error("Database not initialized"));
        return;
      }

      const transaction = this.db.transaction([storeName], "readonly");
      const store = transaction.objectStore(storeName);
      const request = store.getAll();

      request.onerror = (event) => {
        reject((event.target as IDBRequest).error);
      };

      request.onsuccess = (event) => {
        resolve((event.target as IDBRequest).result as T[]);
      };
    });
  }

  async findByIndex<T>(
    storeName: string,
    indexName: string,
    value: IDBValidKey
  ): Promise<T | undefined> {
    return new Promise((resolve, reject) => {
      if (!this.db) {
        reject(new Error("Database not initialized"));
        return;
      }

      const transaction = this.db.transaction([storeName], "readonly");
      const store = transaction.objectStore(storeName);
      const index = store.index(indexName);
      const request = index.get(value);

      request.onerror = (event) => {
        reject((event.target as IDBRequest).error);
      };

      request.onsuccess = (event) => {
        resolve((event.target as IDBRequest).result as T);
      };
    });
  }
}

const browserDB = new BrowserDatabase();

type ModelMethods<T> = {
  create: (data: T) => Promise<IDBValidKey>;
  findByPk: (id: IDBValidKey) => Promise<T | undefined>;
  update: (id: IDBValidKey, data: T) => Promise<IDBValidKey>;
  destroy: (id: IDBValidKey) => Promise<void>;
  findAll: () => Promise<T[]>;
  findOne: (options: {
    where: { [key: string]: IDBValidKey };
  }) => Promise<T | undefined>;
};

function createModelMethods<T>(storeName: string): ModelMethods<T> {
  return {
    create: async (data) => await browserDB.addData<T>(storeName, data),
    findByPk: async (id) => await browserDB.getData<T>(storeName, id),
    update: async (id, data) =>
      await browserDB.updateData<T>(storeName, id, data),
    destroy: async (id) => await browserDB.deleteData(storeName, id),
    findAll: async () => await browserDB.getAllData<T>(storeName),
    findOne: async (options) => {
      if (options.where) {
        const [key, value] = Object.entries(options.where)[0];
        return await browserDB.findByIndex<T>(storeName, key, value);
      }
      return undefined;
    },
  };
}

export const models = {
  SupernodeList: createModelMethods<SupernodeList>("SupernodeList"),
  Message: createModelMethods<Message>("Message"),
  UserMessage: createModelMethods<UserMessage>("UserMessage"),
  CreditPackPurchaseRequest: createModelMethods<CreditPackPurchaseRequest>(
    "CreditPackPurchaseRequest"
  ),
  CreditPackPurchaseRequestRejection:
    createModelMethods<CreditPackPurchaseRequestRejection>(
      "CreditPackPurchaseRequestRejection"
    ),
  CreditPackPurchaseRequestPreliminaryPriceQuote:
    createModelMethods<CreditPackPurchaseRequestPreliminaryPriceQuote>(
      "CreditPackPurchaseRequestPreliminaryPriceQuote"
    ),
  CreditPackPurchaseRequestPreliminaryPriceQuoteResponse:
    createModelMethods<CreditPackPurchaseRequestPreliminaryPriceQuoteResponse>(
      "CreditPackPurchaseRequestPreliminaryPriceQuoteResponse"
    ),
  CreditPackPurchaseRequestResponseTermination:
    createModelMethods<CreditPackPurchaseRequestResponseTermination>(
      "CreditPackPurchaseRequestResponseTermination"
    ),
  CreditPackPurchaseRequestResponse:
    createModelMethods<CreditPackPurchaseRequestResponse>(
      "CreditPackPurchaseRequestResponse"
    ),
  CreditPackPurchaseRequestConfirmation:
    createModelMethods<CreditPackPurchaseRequestConfirmation>(
      "CreditPackPurchaseRequestConfirmation"
    ),
  CreditPackPurchaseRequestConfirmationResponse:
    createModelMethods<CreditPackPurchaseRequestConfirmationResponse>(
      "CreditPackPurchaseRequestConfirmationResponse"
    ),
  CreditPackRequestStatusCheck:
    createModelMethods<CreditPackRequestStatusCheck>(
      "CreditPackRequestStatusCheck"
    ),
  CreditPackPurchaseRequestStatus:
    createModelMethods<CreditPackPurchaseRequestStatus>(
      "CreditPackPurchaseRequestStatus"
    ),
  CreditPackStorageRetryRequest:
    createModelMethods<CreditPackStorageRetryRequest>(
      "CreditPackStorageRetryRequest"
    ),
  CreditPackStorageRetryRequestResponse:
    createModelMethods<CreditPackStorageRetryRequestResponse>(
      "CreditPackStorageRetryRequestResponse"
    ),
  InferenceAPIUsageRequest: createModelMethods<InferenceAPIUsageRequest>(
    "InferenceAPIUsageRequest"
  ),
  InferenceAPIUsageResponse: createModelMethods<InferenceAPIUsageResponse>(
    "InferenceAPIUsageResponse"
  ),
  InferenceAPIOutputResult: createModelMethods<InferenceAPIOutputResult>(
    "InferenceAPIOutputResult"
  ),
  InferenceConfirmation: createModelMethods<InferenceConfirmation>(
    "InferenceConfirmation"
  ),
};

export async function initializeDatabase(): Promise<void> {
  try {
    await browserDB.initializeDatabase();
    console.log("Database initialized successfully");
  } catch (error) {
    console.error("Failed to initialize database:", error);
  }
}


---
./src/app/store/useStore.ts
---
import { create } from 'zustand'

interface PastelState {
  pastelId: string
  setPastelId: (id: string) => void
  creditPacks: any[]
  setCreditPacks: (packs: any[]) => void
  // Add more state and actions as needed
}

const useStore = create<PastelState>((set) => ({
  pastelId: '',
  setPastelId: (id) => set({ pastelId: id }),
  creditPacks: [],
  setCreditPacks: (packs) => set({ creditPacks: packs }),
  // Implement more actions
}))

export default useStore

---
./src/app/components/Terminal.tsx
---


---
./src/app/components/CreditPackTable.tsx
---
import React from 'react'
import { Table } from 'antd'
import type { ColumnsType } from 'antd/es/table'

interface CreditPack {
  id: string
  credits: number
  balance: number
  address: string
  blockHeight: number
  txid: string
}

const columns: ColumnsType<CreditPack> = [
  {
    title: 'Credits',
    dataIndex: 'credits',
    key: 'credits',
  },
  {
    title: 'Balance',
    dataIndex: 'balance',
    key: 'balance',
  },
  {
    title: 'Address',
    dataIndex: 'address',
    key: 'address',
  },
  {
    title: 'Block Height',
    dataIndex: 'blockHeight',
    key: 'blockHeight',
  },
  {
    title: 'TXID',
    dataIndex: 'txid',
    key: 'txid',
  },
]

const CreditPackTable: React.FC<{ creditPacks: CreditPack[] }> = ({ creditPacks }) => (
  <Table columns={columns} dataSource={creditPacks} rowKey="id" />
)

export default CreditPackTable

---
./src/app/components/Layout.tsx
---
import React from 'react'
import { Layout as AntLayout, Menu } from 'antd'
import { 
  HomeOutlined, 
  DollarOutlined, 
  ApiOutlined 
} from '@ant-design/icons'

const { Header, Content, Footer } = AntLayout

const Layout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <AntLayout className="min-h-screen">
      <Header>
        <div className="logo" />
        <Menu theme="dark" mode="horizontal" defaultSelectedKeys={['1']}>
          <Menu.Item key="1" icon={<HomeOutlined />}>
            Home
          </Menu.Item>
          <Menu.Item key="2" icon={<DollarOutlined />}>
            Credit Packs
          </Menu.Item>
          <Menu.Item key="3" icon={<ApiOutlined />}>
            Inference
          </Menu.Item>
        </Menu>
      </Header>
      <Content className="p-8">
        <div className="bg-white p-6 min-h-[280px]">
          {children}
        </div>
      </Content>
      <Footer className="text-center">
        Pastel Inference Client ©{new Date().getFullYear()} Created with Next.js 14
      </Footer>
    </AntLayout>
  )
}

export default Layout

---
./src/app/components/InferenceForm.tsx
---
import React from 'react'
import { Form, Input, Button, Select } from 'antd'

const { TextArea } = Input
const { Option } = Select

const InferenceForm: React.FC<{ pastelId: string }> = ({ pastelId }) => {
  const [form] = Form.useForm()

  const onFinish = (values: any) => {
    console.log('Form values:', values)
    // Handle form submission
  }

  return (
    <Form form={form} onFinish={onFinish} layout="vertical">
      <Form.Item name="inferenceType" label="Inference Type" rules={[{ required: true }]}>
        <Select>
          <Option value="text_completion">Text Completion</Option>
          <Option value="image_generation">Image Generation</Option>
          {/* Add more options */}
        </Select>
      </Form.Item>
      <Form.Item name="prompt" label="Prompt" rules={[{ required: true }]}>
        <TextArea rows={4} />
      </Form.Item>
      <Form.Item name="maxCost" label="Max Cost (Credits)" rules={[{ required: true }]}>
        <Input type="number" />
      </Form.Item>
      <Form.Item>
        <Button type="primary" htmlType="submit">
          Submit Inference Request
        </Button>
      </Form.Item>
    </Form>
  )
}

export default InferenceForm

---
./src/app/types/index.ts
---
// src/app/types/index.ts

export interface LogEntry {
    level: string;
    msg: string;
    meta: unknown;
    timestamp: string;
  }
  
export interface LoggerListener {
  (data: string): void;
}

export interface BrowserLogger {
  logBuffer: string[];
  MAX_LOG_ENTRIES: number;
  listeners: Map<string, Set<LoggerListener>>;
  log(level: string, msg: string, meta?: unknown): void;
  error(msg: string, meta?: unknown): void;
  warn(msg: string, meta?: unknown): void;
  info(msg: string, meta?: unknown): void;
  debug(msg: string, meta?: unknown): void;
  safeStringify(obj: unknown): string;
  on(eventName: string, listener: LoggerListener): void;
  off(eventName: string, listener: LoggerListener): void;
  emit(eventName: string, data: string): void;
}

export interface PastelGlobals {
  MY_LOCAL_PASTELID: string | null;
  MY_PASTELID_PASSPHRASE: string | null;
  MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE: number;
  setPastelIdAndPassphrase(pastelId: string, passphrase: string): void;
  getPastelIdAndPassphrase(): {
    pastelID: string | null;
    passphrase: string | null;
  };
  getPastelId(): string | null;
  getPassphrase(): string | null;
}

export interface PastelInferenceClientConfig {
  pastelID: string;
  passphrase: string;
}

export interface ChallengeResponse {
  challenge: string;
  challenge_id: string;
  challenge_signature: string;
}

export interface ModelParameter {
  name: string;
  description: string;
  type: string;
  default: string | number;
  inference_types_parameter_applies_to: string[];
}

export interface ModelInfo {
  model_name: string;
  supported_inference_type_strings: string[];
  model_parameters: ModelParameter[];
}

export interface ModelMenu {
  models: ModelInfo[];
}

export interface SupernodeResponse {
  response: unknown;
  url: string;
}

export interface ValidCreditPackTicket {
  credit_pack_registration_txid: string;
  credit_purchase_request_confirmation_pastel_block_height: number;
  requesting_end_user_pastelid: string;
  ticket_input_data_fully_parsed_sha3_256_hash: string;
  txid_of_credit_purchase_burn_transaction: string;
  credit_usage_tracking_psl_address: string;
  psl_cost_per_credit: number;
  requested_initial_credits_in_credit_pack: number;
  credit_pack_current_credit_balance: number;
  balance_as_of_datetime: string;
  number_of_confirmation_transactions: number;
}

export interface BalanceInfo {
  [key: string]: unknown;
}

export interface SupernodeWithDistance extends SupernodeInfo {
  distance: bigint;
}

export interface ModelParameter {
  name: string;
  description: string;
  type: string;
  default: string | number;
  inference_types_parameter_applies_to: string[];
  options?: string[];
}

export interface Model {
  model_name: string;
  supported_inference_type_strings: string[];
  model_parameters: ModelParameter[];
}

export interface ModelMenu {
  models: Model[];
}

export interface CachedItem<T> {
  key: string;
  data: T;
  timestamp: number;
}

export interface ValidationError {
  message: string;
}

export interface SupernodeListResult {
    validMasternodeListFullDF: SupernodeInfo[];
    filter: (predicate: (supernode: SupernodeInfo) => boolean) => SupernodeInfo[];
  }

  export interface AuditResult {
    inference_response_id: string;
    inference_request_id: string;
    inference_result_id: string;
    proposed_cost_of_request_in_inference_credits: number;
    remaining_credits_in_pack_after_request_processed: number;
    credit_usage_tracking_psl_address: string;
    request_confirmation_message_amount_in_patoshis: number;
    max_block_height_to_include_confirmation_transaction: number;
    supernode_pastelid_and_signature_on_inference_request_response_hash: string;
    responding_supernode_pastelid: string;
    inference_result_json_base64: string;
    inference_result_file_type_strings: string;
    responding_supernode_signature_on_inference_result_id: string;
  }

export interface InferenceResultDict {
    supernode_url: string;
    request_data: InferenceAPIUsageRequest;
    usage_request_response: InferenceAPIUsageResponse;
    model_input_data_json: unknown;
    output_results: InferenceAPIOutputResult;
    generated_image_decoded?: string;
    zip_file_data?: string;
    inference_result_decoded?: string;
  }

export interface CreditPackTicketInfo {
  requestResponse: CreditPackPurchaseRequestResponse;
  requestConfirmation: CreditPackPurchaseRequestConfirmation;
  balanceInfo: {
    credit_pack_current_credit_balance: number;
    balance_as_of_datetime: string;
  };
}

export interface PreliminaryPriceQuote {
  preliminary_quoted_price_per_credit_in_psl: number;
  preliminary_total_cost_of_credit_pack_in_psl: number;
  credit_pack_purchase_request_fields_json_b64: string;
  [key: string]: unknown;
}

export interface InferenceRequestData {
  id?: number | string;
  requesting_pastelid: string;
  credit_pack_ticket_pastel_txid: string;
  requested_model_canonical_string: string;
  model_inference_type_string: string;
  model_parameters_json_b64: string;
  model_input_data_json_b64: string;
  inference_request_utc_iso_string: string;
  inference_request_pastel_block_height: number;
  status: string;
  inference_request_message_version_string: string;
  sha3_256_hash_of_inference_request_fields: string;
  requesting_pastelid_signature_on_request_hash: string;
}

export interface InferenceConfirmationData {
  id?: number | string;
  inference_request_id: string;
  requesting_pastelid: string;
  confirmation_transaction: {
    txid: string;
  };
}

export interface CreditPackEstimation {
  desiredNumberOfCredits: number;
  creditPriceCushionPercentage: number;
}

export interface InferenceRequestParams {
  creditPackTicketPastelTxid: string;
  modelInputData: unknown;
  requestedModelCanonicalString: string;
  modelInferenceTypeString: string;
  modelParameters: unknown;
  maximumInferenceCostInCredits: number;
}

export interface PreliminaryPriceQuote {
  preliminary_quoted_price_per_credit_in_psl: number;
  preliminary_total_cost_of_credit_pack_in_psl: number;
  credit_pack_purchase_request_fields_json_b64: string;
  credit_usage_tracking_psl_address: string;
}

export interface CreditPackCreationResult {
  creditPackRequest: CreditPackPurchaseRequest;
  creditPackPurchaseRequestConfirmation: CreditPackPurchaseRequestConfirmation;
  creditPackStorageRetryRequestResponse?: unknown;
  creditPackPurchaseRequestConfirmationResponse?: CreditPackPurchaseRequestConfirmationResponse;
}

export interface SupernodeURL {
  url: string;
  pastelID: string;
}

export interface SupernodeInfo {
  txid_vout: string;
  supernode_status: string;
  protocol_version: number;
  supernode_psl_address: string;
  lastseentime: number;
  activeseconds: number;
  activedays: number;
  lastpaidtime: number;
  lastpaidblock: number;
  ipaddress_port: string;
  rank: number;
  pubkey: string;
  extAddress: string;
  extP2P: string;
  extKey: string;
  url?: string;
}

export interface WalletInfo {
  walletversion: number;
  balance: number;
  unconfirmed_balance: number;
  immature_balance: number;
  txcount: number;
  keypoololdest: number;
  keypoolsize: number;
  paytxfee: number;
  seedfp: string;
}

export interface CreditPack extends ValidCreditPackTicket {
  id: string;
  credits: number;
  balance: number;
  address: string;
}

export interface InferenceRequest {
  creditPackTicketPastelTxid: string;
  modelInputData: unknown;
  requestedModelCanonicalString: string;
  modelInferenceTypeString: string;
  modelParameters: unknown;
  maximumInferenceCostInCredits: number;
}

export interface InferenceResult {
  supernode_url: string;
  request_data: InferenceAPIUsageRequest;
  usage_request_response: InferenceAPIUsageResponse;
  model_input_data_json: unknown;
  output_results: InferenceAPIOutputResult;
  generated_image_decoded?: string;
  zip_file_data?: string;
  inference_result_decoded?: string;
}

export interface PastelIDTicket {
  ticket: {
    pastelID: string;
    [key: string]: unknown;
  };
}

export enum NetworkMode {
  Mainnet,
  Testnet,
  Devnet,
}

export interface TransactionDetail {
  amount: number;
  confirmations: number;
  blockhash: string;
  blockindex: number;
  blocktime: number;
  txid: string;
  time: number;
  timereceived: number;
  details: {
    account: string;
    address: string;
    category: string;
    amount: number;
    vout: number;
  }[];
  hex: string;
}

export interface BlockInfo {
  hash: string;
  confirmations: number;
  size: number;
  height: number;
  version: number;
  merkleroot: string;
  tx: string[];
  time: number;
  nonce: string;
  bits: string;
  difficulty: number;
  previousblockhash: string;
  nextblockhash?: string;
}

export interface MempoolInfo {
  size: number;
  bytes: number;
  usage: number;
}

export interface BlockchainInfo {
  chain: string;
  blocks: number;
  headers: number;
  bestblockhash: string;
  difficulty: number;
  verificationprogress: number;
  chainwork: string;
}

export interface TxOutSetInfo {
  height: number;
  bestblock: string;
  transactions: number;
  txouts: number;
  bytes_serialized: number;
  hash_serialized: string;
  total_amount: number;
}

export interface ChainTip {
  height: number;
  hash: string;
  branchlen: number;
  status: string;
}

export interface SendToAddressResult {
  success: boolean;
  result?: string;
  message?: string;
}

export interface BlockHeader {
  hash: string;
  confirmations: number;
  height: number;
  version: number;
  merkleroot: string;
  time: number;
  nonce: string;
  bits: string;
  difficulty: number;
  previousblockhash: string;
  nextblockhash?: string;
}

export interface TxOutInfo {
  bestblock: string;
  confirmations: number;
  value: number;
  scriptPubKey: {
    asm: string;
    hex: string;
    reqSigs: number;
    type: string;
    addresses: string[];
  };
  version: number;
  coinbase: boolean;
}

export interface MemoryInfo {
  locked: {
    used: number;
    free: number;
    total: number;
    locked: number;
    chunks_used: number;
    chunks_free: number;
  };
}

export interface BlockSubsidy {
  miner: number;
  masternode: number;
  governance: number;
}

export interface BlockTemplate {
  version: number;
  previousblockhash: string;
  transactions: unknown[];
  coinbaseaux: {
    flags: string;
  };
  coinbasevalue: number;
  longpollid: string;
  target: string;
  mintime: number;
  mutable: string[];
  noncerange: string;
  sigoplimit: number;
  sizelimit: number;
  curtime: number;
  bits: string;
  height: number;
}

export interface MiningInfo {
  blocks: number;
  currentblocksize: number;
  currentblocktx: number;
  difficulty: number;
  errors: string;
  genproclimit: number;
  networkhashps: number;
  pooledtx: number;
  testnet: boolean;
  chain: string;
  generate: boolean;
}

export interface NetworkSolPs {
  networksolps: number;
}

export interface NodeInfo {
  addednode: string;
  connected: boolean;
  addresses: {
    address: string;
    connected: string;
  }[];
}

export interface PeerInfo {
  id: number;
  addr: string;
  addrlocal: string;
  services: string;
  lastsend: number;
  lastrecv: number;
  bytessent: number;
  bytesrecv: number;
  conntime: number;
  timeoffset: number;
  pingtime: number;
  version: number;
  subver: string;
  inbound: boolean;
  startingheight: number;
  banscore: number;
  synced_headers: number;
  synced_blocks: number;
  inflight: number[];
  whitelisted: boolean;
}

export interface DecodedRawTransaction {
  txid: string;
  version: number;
  locktime: number;
  vin: {
    txid: string;
    vout: number;
    scriptSig: {
      asm: string;
      hex: string;
    };
    sequence: number;
  }[];
  vout: {
    value: number;
    n: number;
    scriptPubKey: {
      asm: string;
      hex: string;
      reqSigs: number;
      type: string;
      addresses: string[];
    };
  }[];
}

export interface DecodedScript {
  asm: string;
  hex: string;
  type: string;
  reqSigs: number;
  addresses: string[];
  p2sh: string;
}

export interface ValidatedAddress {
  isvalid: boolean;
  address: string;
  scriptPubKey: string;
  ismine: boolean;
  iswatchonly: boolean;
  isscript: boolean;
}

export interface PastelIDInfo {
  pastelID: string;
  [key: string]: unknown;
}

export interface PastelID {
  pastelID: string | null;
  passphrase: string | null;
}

export interface NetworkInfo {
  network: string;
}

export interface AddressAmount {
  [address: string]: number;
}

export interface SupernodeList {
  id?: number | string;
  txid_vout: string;
  supernode_status: string;
  protocol_version: number;
  supernode_psl_address: string;
  lastseentime: number;
  activeseconds: number;
  activedays: number;
  lastpaidtime: number;
  lastpaidblock: number;
  ipaddress_port: string;
  rank: number;
  pubkey: string;
  extAddress: string;
  extP2P: string;
  extKey: string;
}

export interface Message {
  id: string;
  sending_sn_pastelid: string;
  receiving_sn_pastelid: string;
  sending_sn_txid_vout: string;
  receiving_sn_txid_vout: string;
  message_type: string;
  message_body: string;
  signature: string;
  timestamp: string;
}

export interface UserMessage {
  id: string;
  from_pastelid: string;
  to_pastelid: string;
  message_body: string;
  message_signature: string;
  timestamp: string;
}

export interface CreditPackPurchaseRequest extends Record<string, unknown> {  
  id?: number | string;
  requesting_end_user_pastelid: string;
  requested_initial_credits_in_credit_pack: number;
  list_of_authorized_pastelids_allowed_to_use_credit_pack: string;
  credit_usage_tracking_psl_address: string;
  request_timestamp_utc_iso_string: string;
  request_pastel_block_height: number;
  credit_purchase_request_message_version_string: string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  requesting_end_user_pastelid_signature_on_request_hash: string;
}

export interface CreditPackPurchaseRequestRejection extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  credit_pack_purchase_request_fields_json_b64: string;
  rejection_reason_string: string;
  rejection_timestamp_utc_iso_string: string;
  rejection_pastel_block_height: number;
  credit_purchase_request_rejection_message_version_string: string;
  responding_supernode_pastelid: string;
  sha3_256_hash_of_credit_pack_purchase_request_rejection_fields: string;
  responding_supernode_signature_on_credit_pack_purchase_request_rejection_hash: string;
}

export interface CreditPackPurchaseRequestPreliminaryPriceQuote extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  credit_usage_tracking_psl_address: string;
  credit_pack_purchase_request_fields_json_b64: string;
  preliminary_quoted_price_per_credit_in_psl: number;
  preliminary_total_cost_of_credit_pack_in_psl: number;
  preliminary_price_quote_timestamp_utc_iso_string: string;
  preliminary_price_quote_pastel_block_height: number;
  preliminary_price_quote_message_version_string: string;
  responding_supernode_pastelid: string;
  sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields: string;
  responding_supernode_signature_on_credit_pack_purchase_request_preliminary_price_quote_hash: string;
}

export interface CreditPackPurchaseRequestPreliminaryPriceQuoteResponse extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields: string;
  credit_pack_purchase_request_fields_json_b64: string;
  agree_with_preliminary_price_quote: boolean;
  credit_usage_tracking_psl_address: string;
  preliminary_quoted_price_per_credit_in_psl: number;
  preliminary_price_quote_response_timestamp_utc_iso_string: string;
  preliminary_price_quote_response_pastel_block_height: number;
  preliminary_price_quote_response_message_version_string: string;
  requesting_end_user_pastelid: string;
  sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields: string;
  requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash: string;
}

export interface CreditPackPurchaseRequestResponseTermination extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  credit_pack_purchase_request_fields_json_b64: string;
  termination_reason_string: string;
  termination_timestamp_utc_iso_string: string;
  termination_pastel_block_height: number;
  credit_purchase_request_termination_message_version_string: string;
  responding_supernode_pastelid: string;
  sha3_256_hash_of_credit_pack_purchase_request_termination_fields: string;
  responding_supernode_signature_on_credit_pack_purchase_request_termination_hash: string;
}

export interface CreditPackPurchaseRequestResponse extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  credit_pack_purchase_request_fields_json_b64: string;
  psl_cost_per_credit: number;
  proposed_total_cost_of_credit_pack_in_psl: number;
  credit_usage_tracking_psl_address: string;
  request_response_timestamp_utc_iso_string: string;
  request_response_pastel_block_height: number;
  best_block_merkle_root: string;
  best_block_height: number;
  credit_purchase_request_response_message_version_string: string;
  responding_supernode_pastelid: string;
  list_of_blacklisted_supernode_pastelids: string;
  list_of_potentially_agreeing_supernodes: string;
  list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms: string;
  list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms_selected_for_signature_inclusion: string;
  selected_agreeing_supernodes_signatures_dict: string;
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: string;
  responding_supernode_signature_on_credit_pack_purchase_request_response_hash: string;
}

export interface CreditPackPurchaseRequestConfirmation extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: string;
  credit_pack_purchase_request_fields_json_b64: string;
  requesting_end_user_pastelid: string;
  txid_of_credit_purchase_burn_transaction: string;
  credit_purchase_request_confirmation_utc_iso_string: string;
  credit_purchase_request_confirmation_pastel_block_height: number;
  credit_purchase_request_confirmation_message_version_string: string;
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: string;
  requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: string;
}

export interface CreditPackPurchaseRequestConfirmationResponse extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: string;
  credit_pack_confirmation_outcome_string: string;
  pastel_api_credit_pack_ticket_registration_txid: string;
  credit_pack_confirmation_failure_reason_if_applicable: string | null;
  credit_purchase_request_confirmation_response_utc_iso_string: string;
  credit_purchase_request_confirmation_response_pastel_block_height: number;
  credit_purchase_request_confirmation_response_message_version_string: string;
  responding_supernode_pastelid: string;
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_response_fields: string;
  responding_supernode_signature_on_credit_pack_purchase_request_confirmation_response_hash: string;
}

export interface CreditPackRequestStatusCheck extends Record<string, unknown> {  
    sha3_256_hash_of_credit_pack_purchase_request_fields: string;
    requesting_end_user_pastelid: string;
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  }

export interface CreditPackPurchaseRequestStatus extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: string;
  status: string;
  status_details: string;
  status_update_timestamp_utc_iso_string: string;
  status_update_pastel_block_height: number;
  credit_purchase_request_status_message_version_string: string;
  responding_supernode_pastelid: string;
  sha3_256_hash_of_credit_pack_purchase_request_status_fields: string;
  responding_supernode_signature_on_credit_pack_purchase_request_status_hash: string;
}

export interface CreditPackStorageRetryRequest extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_response_fields: string;
  credit_pack_purchase_request_fields_json_b64: string;
  requesting_end_user_pastelid: string;
  closest_agreeing_supernode_to_retry_storage_pastelid: string;
  credit_pack_storage_retry_request_timestamp_utc_iso_string: string;
  credit_pack_storage_retry_request_pastel_block_height: number;
  credit_pack_storage_retry_request_message_version_string: string;
  sha3_256_hash_of_credit_pack_storage_retry_request_fields: string;
  requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash: string;
}

export interface CreditPackStorageRetryRequestResponse extends Record<string, unknown> {  
  id?: number | string;
  sha3_256_hash_of_credit_pack_purchase_request_fields: string;
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: string;
  credit_pack_storage_retry_confirmation_outcome_string: string;
  pastel_api_credit_pack_ticket_registration_txid: string;
  credit_pack_storage_retry_confirmation_failure_reason_if_applicable: string;
  credit_pack_storage_retry_confirmation_response_utc_iso_string: string;
  credit_pack_storage_retry_confirmation_response_pastel_block_height: number;
  credit_pack_storage_retry_confirmation_response_message_version_string: string;
  closest_agreeing_supernode_to_retry_storage_pastelid: string;
  sha3_256_hash_of_credit_pack_storage_retry_confirmation_response_fields: string;
  closest_agreeing_supernode_to_retry_storage_pastelid_signature_on_credit_pack_storage_retry_confirmation_response_hash: string;
}

export interface InferenceAPIUsageRequest extends Record<string, unknown> {  
  id?: number | string;
  inference_request_id: string;
  requesting_pastelid: string;
  credit_pack_ticket_pastel_txid: string;
  requested_model_canonical_string: string;
  model_inference_type_string: string;
  model_parameters_json_b64: string;
  model_input_data_json_b64: string;
  inference_request_utc_iso_string: string;
  inference_request_pastel_block_height: number;
  status: string;
  inference_request_message_version_string: string;
  sha3_256_hash_of_inference_request_fields: string;
  requesting_pastelid_signature_on_request_hash: string;
}

export interface InferenceAPIUsageResponse extends Record<string, unknown> {  
  id?: number | string;
  inference_response_id: string;
  inference_request_id: string;
  proposed_cost_of_request_in_inference_credits: number;
  remaining_credits_in_pack_after_request_processed: number;
  credit_usage_tracking_psl_address: string;
  request_confirmation_message_amount_in_patoshis: number;
  max_block_height_to_include_confirmation_transaction: number;
  inference_request_response_utc_iso_string: string;
  inference_request_response_pastel_block_height: number;
  inference_request_response_message_version_string: string;
  sha3_256_hash_of_inference_request_response_fields: string;
  supernode_pastelid_and_signature_on_inference_request_response_hash: string;
}

export interface InferenceAPIOutputResult extends Record<string, unknown> {  
  id?: number | string;
  inference_result_id: string;
  inference_request_id: string;
  inference_response_id: string;
  responding_supernode_pastelid: string;
  inference_result_json_base64: string;
  inference_result_file_type_strings: string;
  inference_result_utc_iso_string: string;
  inference_result_pastel_block_height: number;
  inference_result_message_version_string: string;
  sha3_256_hash_of_inference_result_fields: string;
  responding_supernode_signature_on_inference_result_id: string;
}

export interface InferenceConfirmation extends Record<string, unknown> {  
  id?: number | string;
  inference_request_id: string;
  requesting_pastelid: string;
  confirmation_transaction: {
    txid: string;
  };
}

export interface ValidationResult extends Record<string, unknown> {  
  inference_result_id: string;
  inference_response_id: string;
  inference_request_id: string;
  proposed_cost_in_credits: number;
  remaining_credits_after_request: number;
  credit_usage_tracking_psl_address: string;
  request_confirmation_message_amount_in_patoshis: number;
  max_block_height_to_include_confirmation_transaction: number;
  supernode_pastelid_and_signature_on_inference_response_id: unknown;
  responding_supernode_pastelid: string;
  inference_result_json_base64: string;
  inference_result_file_type_strings: unknown;
  responding_supernode_signature_on_inference_result_id: string;
}

---
